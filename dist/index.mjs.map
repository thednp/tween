{"version":3,"file":"index.mjs","names":[],"sources":["../src/Now.ts","../src/Runtime.ts","../src/Tween.ts","../src/Timeline.ts","../src/Easing.ts","../src/interpolators/array.ts","../src/interpolators/path.ts"],"sourcesContent":["let _nowFunc = () => performance.now();\n\nexport const now = (): number => {\n  return _nowFunc();\n};\n\nexport function setNow(nowFunction: typeof _nowFunc) {\n  _nowFunc = nowFunction;\n}\n","// Runtime.ts\nimport { type Tween } from \"./Tween.ts\";\nimport { type Timeline } from \"./Timeline.ts\";\nimport { now } from \"./Now.ts\";\n\nexport const Tweens: Tween<never>[] = [];\nexport const Timelines: Timeline<never>[] = [];\nexport let rafID = 0;\n\nexport function Runtime(t = now()) {\n  let j = 0;\n  while (j < Timelines.length) {\n    if (Timelines[j].update(t)) {\n      j += 1;\n    } else {\n      Timelines.splice(j, 1);\n    }\n  }\n\n  let i = 0;\n  while (i < Tweens.length) {\n    if (Tweens[i].update(t)) {\n      i += 1;\n    } else {\n      Tweens.splice(i, 1);\n    }\n  }\n\n  if (!Tweens.length && !Timelines.length) {\n    cancelAnimationFrame(rafID);\n    rafID = 0;\n  } else rafID = requestAnimationFrame(Runtime);\n}\n","// Tween.ts\nimport type {\n  BaseTweenProps,\n  EasingFunction,\n  TweenCallback,\n  TweenProps,\n  TweenUpdateCallback,\n} from \"./types.ts\";\nimport { rafID, Runtime, Tweens } from \"./Runtime.ts\";\nimport { now } from \"./Now.ts\";\n\nexport class Tween<T extends TweenProps = never> {\n  static Interpolators = new Map<\n    string,\n    <T extends never>(start: T, end: T, value: number) => T\n  >();\n  protected _object: T;\n  protected _startIsSet = false;\n  protected _startFired = false;\n  protected _propsStart: TweenProps = {};\n  protected _propsEnd: TweenProps = {};\n  protected _isPlaying = false;\n  protected _duration = 1000;\n  protected _delay = 0;\n  protected _easing: EasingFunction = (t) => t;\n  protected _startTime: number = 0;\n  protected _onUpdate?: TweenUpdateCallback<T>;\n  protected _onComplete?: TweenCallback<T>;\n  protected _onStart?: TweenCallback<T>;\n  protected _onStop?: TweenCallback<T>;\n\n  constructor(initialValues: T) {\n    this._object = initialValues;\n    return this;\n  }\n\n  get isPlaying(): boolean {\n    return this._isPlaying;\n  }\n\n  start(time = now(), overrideStart = false) {\n    if (this._isPlaying) return this;\n    if (!this._startIsSet || overrideStart) {\n      this._startIsSet = true;\n\n      this._setupProperties(\n        this._object,\n        this._propsStart,\n        this._propsEnd,\n        overrideStart,\n      );\n    }\n    this._isPlaying = true;\n    this._onStart?.(this._object);\n    Tweens.push(this as unknown as Tween<never>);\n    this._startTime = time;\n    this._startTime += this._delay;\n    if (!rafID) Runtime();\n    return this;\n  }\n  startFromLast(time = now()) {\n    return this.start(time, true);\n  }\n  stop() {\n    if (!this._isPlaying) return this;\n    Tweens.splice(Tweens.indexOf(this as unknown as Tween<never>), 1);\n    this._isPlaying = false;\n    if (this._onStop) this._onStop(this._object);\n    return this;\n  }\n  from(startValues: Partial<T>) {\n    // this._propsStart = startValues as T;\n    Object.assign(this._propsStart, startValues);\n    this._startIsSet = false;\n\n    return this;\n  }\n  to(endValues: Partial<T>) {\n    this._propsEnd = endValues as T;\n    this._startIsSet = false;\n\n    return this;\n  }\n  duration(seconds = 1) {\n    this._duration = seconds * 1000;\n    return this;\n  }\n  delay(seconds = 0) {\n    this._delay = seconds * 1000;\n    return this;\n  }\n  easing(easing: EasingFunction = (t) => t) {\n    this._easing = easing;\n    return this;\n  }\n  getDuration() {\n    return this._duration;\n  }\n  /**\n   * @param time - The current time\n   * @param autoStart - When true, calling update will implicitly call start()\n   * as well. Note, if you stop() or end() the tween, but are still calling\n   * update(), it will start again!\n   *\n   * @returns true if the tween is still playing after the update, false\n   * otherwise (calling update on a paused tween still returns true because\n   * it is still playing, just paused).\n   */\n  update(time = now(), autoStart?: boolean) {\n    if (!this._isPlaying) {\n      if (autoStart) this.start(time, true);\n      else return false;\n    }\n\n    if (time < this._startTime) {\n      return true;\n    }\n\n    if (!this._startFired && this._onStart) {\n      this._onStart(this._object);\n      this._startFired = true;\n    }\n\n    let elapsed = (time - this._startTime) / this._duration;\n    elapsed = this._duration === 0 || elapsed > 1 ? 1 : elapsed;\n    const progress = this._easing(elapsed);\n\n    this._updateProperties(\n      this._object,\n      this._propsStart,\n      this._propsEnd,\n      progress,\n    );\n\n    if (this._onUpdate) {\n      this._onUpdate(this._object, elapsed, progress);\n    }\n\n    if (elapsed === 1) {\n      if (this._onComplete) {\n        this._onComplete(this._object);\n      }\n      this._isPlaying = false;\n\n      return false;\n    }\n    return true;\n  }\n\n  onUpdate(callback?: TweenUpdateCallback<T>) {\n    this._onUpdate = callback;\n    return this;\n  }\n  onComplete(callback: TweenCallback<T>) {\n    this._onComplete = callback;\n    return this;\n  }\n  onStop(callback: TweenCallback<T>) {\n    this._onStop = callback;\n    return this;\n  }\n  onStart(callback: TweenCallback<T>) {\n    this._onStart = callback;\n    return this;\n  }\n  private _updateProperties(\n    object: TweenProps,\n    valuesStart: TweenProps,\n    valuesEnd: TweenProps,\n    value: number,\n  ): void {\n    for (const property in valuesEnd) {\n      // Don't update properties that do not exist in the source object\n      if (valuesStart[property] === undefined) continue;\n\n      const start = valuesStart[property];\n      const end = valuesEnd[property];\n\n      // Protect against non matching properties.\n      if (start.constructor !== end.constructor) continue;\n\n      // Protect against non numeric properties.\n      if (typeof end === \"number\") {\n        const startNum = start as number;\n        object[property] = startNum + (end - startNum) * value;\n      } else if (Tween.Interpolators.has(property)) {\n        const interpolator = Tween.Interpolators.get(property)!;\n        object[property] = interpolator(start as never, end as never, value);\n      } else if (typeof end === \"object\") {\n        this._updateProperties(\n          object[property] as BaseTweenProps,\n          start as BaseTweenProps,\n          end as BaseTweenProps,\n          value,\n        );\n      }\n    }\n  }\n  protected _setupProperties(\n    obj: T,\n    propsStart: TweenProps,\n    propsEnd: TweenProps,\n    overrideStartingValues: boolean,\n  ): void {\n    for (const property in propsEnd) {\n      const startValue = obj[property];\n\n      // Save the starting value, but only once unless override is requested.\n      if (\n        typeof propsStart[property] === \"undefined\" ||\n        overrideStartingValues\n      ) {\n        propsStart[property] = startValue;\n      }\n    }\n  }\n  static use(\n    property: string,\n    interpolateFn: <T extends never>(start: T, end: T, t: number) => T,\n  ): void {\n    if (!Tween.Interpolators.has(property)) {\n      Tween.Interpolators.set(property, interpolateFn);\n    }\n  }\n}\n","// Timeline.ts\nimport type {\n  BaseTweenProps,\n  Position,\n  TimelineCallback,\n  TimelineEntry,\n  TimelineEntryConfig,\n  TweenProps,\n} from \"./types.ts\";\nimport { rafID, Runtime, Timelines } from \"./Runtime.ts\";\nimport { now } from \"./Now.ts\";\n\nexport class Timeline<T extends TweenProps = never> {\n  static Interpolators = new Map<\n    string,\n    <T extends never>(start: T, end: T, value: number) => T\n  >();\n  public state: T;\n  public _state: T;\n  private _entries: TimelineEntry<T>[] = [];\n  private _labels = new Map<string, number>();\n  private _progress = 0;\n  private _duration = 0;\n  private _time = 0;\n  private _pauseTime = 0;\n  private _lastTime?: number;\n  private _isPlaying = false;\n  private _repeat = 0;\n  private _initialRepeat = 0;\n  private _onStart?: TimelineCallback<T>;\n  private _onStop?: TimelineCallback<T>;\n  private _onPause?: TimelineCallback<T>;\n  private _onResume?: TimelineCallback<T>;\n  private _onUpdate?: TimelineCallback<T>;\n  private _onComplete?: TimelineCallback<T>;\n\n  constructor(initialState: T) {\n    this.state = initialState;\n    this._state = { ...initialState };\n  }\n\n  to(\n    {\n      duration = 1,\n      easing = (t) => t,\n      ...values\n    }: Partial<T> & TimelineEntryConfig,\n    position: Position = \"+=0\",\n  ): this {\n    const startTime = this._resolvePosition(position);\n    const to = values as Partial<T>;\n    const entryDuration = duration * 1000;\n\n    this._entries.push({\n      to,\n      startTime,\n      duration: entryDuration,\n      easing,\n      hasStarted: false,\n    });\n\n    const endTime = startTime + entryDuration;\n    this._duration = Math.max(this._duration, endTime);\n\n    return this;\n  }\n\n  play(): this {\n    if (this._pauseTime) return this.resume();\n    if (this._isPlaying) return this;\n\n    this._isPlaying = true;\n    this._lastTime = undefined;\n    this._time = 0;\n    this._resetState();\n    this._updateEntries(0);\n    this._onStart?.(this.state, 0);\n\n    Timelines.push(this as unknown as Timeline<never>);\n    if (!rafID) Runtime();\n    return this;\n  }\n\n  pause(): this {\n    if (!this._isPlaying) return this;\n    this._isPlaying = false;\n    this._pauseTime = now();\n    this._onPause?.(this.state, this.progress);\n    return this;\n  }\n\n  resume(time = now()): this {\n    if (this._isPlaying) return this;\n    this._isPlaying = true;\n    const dif = time - this._pauseTime;\n    this._pauseTime = 0;\n    this._lastTime = (this._lastTime || time) + dif;\n    this._onResume?.(this.state, this.progress);\n    Timelines.push(this as unknown as Timeline<never>);\n    if (!rafID) Runtime();\n    return this;\n  }\n\n  stop(): this {\n    if (!this._isPlaying) return this;\n    this._isPlaying = false;\n    this._time = 0;\n    this._pauseTime = 0;\n    Timelines.splice(Timelines.indexOf(this as unknown as Timeline<never>), 1);\n    this._resetState();\n    this._updateEntries(0);\n    if (this._onStop) this._onStop(this.state, this.progress);\n    return this;\n  }\n\n  repeat(count = 0): this {\n    this._repeat = count;\n    this._initialRepeat = count;\n    return this;\n  }\n\n  seek(pointer: number | string): this {\n    const elapsed = this._resolvePosition(pointer);\n    this._resetState();\n    this._time = Math.max(0, elapsed);\n    this._updateEntries(this._time);\n    return this;\n  }\n\n  label(name: string, position: Position = this._duration): this {\n    this._labels.set(name, this._resolvePosition(position));\n    return this;\n  }\n\n  onStart(cb: TimelineCallback<T>): this {\n    this._onStart = cb;\n    return this;\n  }\n\n  onPause(cb: TimelineCallback<T>): this {\n    this._onPause = cb;\n    return this;\n  }\n\n  onResume(cb: TimelineCallback<T>): this {\n    this._onResume = cb;\n    return this;\n  }\n\n  onStop(cb: TimelineCallback<T>): this {\n    this._onStop = cb;\n    return this;\n  }\n\n  onUpdate(cb: TimelineCallback<T>): this {\n    this._onUpdate = cb;\n    return this;\n  }\n\n  onComplete(cb: TimelineCallback<T>): this {\n    this._onComplete = cb;\n    return this;\n  }\n\n  get progress(): number {\n    return this._progress;\n  }\n\n  get duration(): number {\n    return this._duration;\n  }\n\n  update(time = now()) {\n    if (!this._isPlaying) return false;\n    if (this._lastTime === undefined) this._lastTime = time;\n    const delta = time - this._lastTime;\n    this._lastTime = time;\n    this._time += delta;\n\n    this._updateEntries(this._time);\n\n    if (this._progress === 1) {\n      if (this._repeat === 0) {\n        this._isPlaying = false;\n        this._repeat = this._initialRepeat;\n        Timelines.splice(\n          Timelines.indexOf(this as unknown as Timeline<never>),\n          1,\n        );\n        this._onComplete?.(this.state, 1);\n      } else {\n        if (this._repeat !== Infinity) this._repeat--;\n        this._time = 0;\n        this._resetState();\n        this._updateEntries(0);\n      }\n    }\n    return this._isPlaying;\n  }\n\n  private _updateEntries(elapsed: number) {\n    this._progress = this._duration === 0 || elapsed >= this._duration\n      ? 1\n      : elapsed / this._duration;\n\n    let i = 0;\n    const entriesLen = this._entries.length;\n    while (i < entriesLen) {\n      const entry = this._entries[i];\n      const localTime = elapsed - entry.startTime;\n      const tweenElapsed = Math.max(0, Math.min(1, localTime / entry.duration));\n\n      if (!entry.hasStarted && tweenElapsed > 0) {\n        entry.hasStarted = true;\n        entry.startValues = {};\n        for (const key in entry.to) {\n          entry.startValues[key] = this.state[key];\n        }\n      }\n\n      if (entry.hasStarted) {\n        this._setState(\n          this.state,\n          entry.startValues as TweenProps,\n          entry.to,\n          entry.easing(tweenElapsed),\n        );\n      }\n      i += 1;\n    }\n\n    this._onUpdate?.(this.state, this._progress);\n  }\n\n  private _resolvePosition(pos: Position): number {\n    if (typeof pos === \"number\") return pos * 1000;\n\n    if (typeof pos === \"string\") {\n      // First try label\n      const labelTime = this._labels.get(pos);\n      if (labelTime !== undefined) return labelTime;\n\n      // Then relative\n      if (pos.startsWith(\"+=\") || pos.startsWith(\"-=\")) {\n        let offset = parseFloat(pos.slice(2));\n        if (isNaN(offset)) offset = 0;\n        offset *= 1000;\n        return pos.startsWith(\"+=\")\n          ? this._duration + offset\n          : Math.max(0, this._duration - offset);\n      }\n    }\n\n    return this._duration;\n  }\n\n  private _setState(\n    object: TweenProps,\n    valuesStart: TweenProps,\n    valuesEnd: Partial<T> | TweenProps,\n    value: number,\n  ): void {\n    for (const property in valuesEnd) {\n      if (valuesStart[property] === undefined) continue;\n\n      const start = valuesStart[property];\n      const end = valuesEnd[property];\n\n      if (start.constructor !== end?.constructor) continue;\n\n      if (typeof end === \"number\") {\n        const startNum = start as number;\n        object[property] = startNum + (end - startNum) * value;\n      } else if (Timeline.Interpolators.has(property)) {\n        const interpolator = Timeline.Interpolators.get(property)!;\n        object[property] = interpolator(start as never, end as never, value);\n      } else if (typeof end === \"object\") {\n        this._setState(\n          object[property] as BaseTweenProps,\n          start as BaseTweenProps,\n          end as BaseTweenProps,\n          value,\n        );\n      }\n    }\n  }\n\n  private _resetState() {\n    Object.assign(this.state, this._state);\n    let i = 0;\n    const entriesLen = this._entries.length;\n    while (i < entriesLen) {\n      const entry = this._entries[i];\n      entry.hasStarted = false;\n      entry.startValues = undefined;\n      i += 1;\n    }\n  }\n\n  static use(\n    property: string,\n    interpolateFn: <T extends never>(start: T, end: T, t: number) => T,\n  ): void {\n    if (!Timeline.Interpolators.has(property)) {\n      Timeline.Interpolators.set(property, interpolateFn);\n    }\n  }\n}\n","// Easing.ts\nimport type { EasingFunction, EasingFunctionGroup } from \"./types.ts\";\n\n/**\n * The Ease class provides a collection of easing functions for use with tween.js.\n */\n\nexport const Easing = Object.freeze({\n  Linear: Object.freeze<EasingFunctionGroup & { None: EasingFunction }>({\n    None(amount: number): number {\n      return amount;\n    },\n    In(amount: number): number {\n      return amount;\n    },\n    Out(amount: number): number {\n      return amount;\n    },\n    InOut(amount: number): number {\n      return amount;\n    },\n  }),\n\n  Quadratic: Object.freeze(\n    <EasingFunctionGroup> {\n      In(amount: number): number {\n        return amount * amount;\n      },\n      Out(amount: number): number {\n        return amount * (2 - amount);\n      },\n      InOut(amount: number): number {\n        if ((amount *= 2) < 1) {\n          return 0.5 * amount * amount;\n        }\n\n        return -0.5 * (--amount * (amount - 2) - 1);\n      },\n    },\n  ),\n\n  Cubic: Object.freeze(\n    <EasingFunctionGroup> {\n      In(amount: number): number {\n        return amount * amount * amount;\n      },\n      Out(amount: number): number {\n        return --amount * amount * amount + 1;\n      },\n      InOut(amount: number): number {\n        if ((amount *= 2) < 1) {\n          return 0.5 * amount * amount * amount;\n        }\n        return 0.5 * ((amount -= 2) * amount * amount + 2);\n      },\n    },\n  ),\n\n  Quartic: Object.freeze(\n    <EasingFunctionGroup> {\n      In(amount: number): number {\n        return amount * amount * amount * amount;\n      },\n      Out(amount: number): number {\n        return 1 - --amount * amount * amount * amount;\n      },\n      InOut(amount: number): number {\n        if ((amount *= 2) < 1) {\n          return 0.5 * amount * amount * amount * amount;\n        }\n\n        return -0.5 * ((amount -= 2) * amount * amount * amount - 2);\n      },\n    },\n  ),\n\n  Quintic: Object.freeze(\n    <EasingFunctionGroup> {\n      In(amount: number): number {\n        return amount * amount * amount * amount * amount;\n      },\n      Out(amount: number): number {\n        return --amount * amount * amount * amount * amount + 1;\n      },\n      InOut(amount: number): number {\n        if ((amount *= 2) < 1) {\n          return 0.5 * amount * amount * amount * amount * amount;\n        }\n\n        return 0.5 * ((amount -= 2) * amount * amount * amount * amount + 2);\n      },\n    },\n  ),\n\n  Sinusoidal: Object.freeze(\n    <EasingFunctionGroup> {\n      In(amount: number): number {\n        return 1 - Math.sin(((1.0 - amount) * Math.PI) / 2);\n      },\n      Out(amount: number): number {\n        return Math.sin((amount * Math.PI) / 2);\n      },\n      InOut(amount: number): number {\n        return 0.5 * (1 - Math.sin(Math.PI * (0.5 - amount)));\n      },\n    },\n  ),\n\n  Exponential: Object.freeze(\n    <EasingFunctionGroup> {\n      In(amount: number): number {\n        return amount === 0 ? 0 : Math.pow(1024, amount - 1);\n      },\n      Out(amount: number): number {\n        return amount === 1 ? 1 : 1 - Math.pow(2, -10 * amount);\n      },\n      InOut(amount: number): number {\n        if (amount === 0) {\n          return 0;\n        }\n\n        if (amount === 1) {\n          return 1;\n        }\n\n        if ((amount *= 2) < 1) {\n          return 0.5 * Math.pow(1024, amount - 1);\n        }\n\n        return 0.5 * (-Math.pow(2, -10 * (amount - 1)) + 2);\n      },\n    },\n  ),\n\n  Circular: Object.freeze(\n    <EasingFunctionGroup> {\n      In(amount: number): number {\n        return 1 - Math.sqrt(1 - amount * amount);\n      },\n      Out(amount: number): number {\n        return Math.sqrt(1 - --amount * amount);\n      },\n      InOut(amount: number): number {\n        if ((amount *= 2) < 1) {\n          return -0.5 * (Math.sqrt(1 - amount * amount) - 1);\n        }\n        return 0.5 * (Math.sqrt(1 - (amount -= 2) * amount) + 1);\n      },\n    },\n  ),\n\n  Elastic: Object.freeze(\n    <EasingFunctionGroup> {\n      In(amount: number): number {\n        if (amount === 0) {\n          return 0;\n        }\n\n        if (amount === 1) {\n          return 1;\n        }\n\n        return (\n          -Math.pow(2, 10 * (amount - 1)) *\n          Math.sin((amount - 1.1) * 5 * Math.PI)\n        );\n      },\n      Out(amount: number): number {\n        if (amount === 0) {\n          return 0;\n        }\n\n        if (amount === 1) {\n          return 1;\n        }\n        return (\n          Math.pow(2, -10 * amount) * Math.sin((amount - 0.1) * 5 * Math.PI) + 1\n        );\n      },\n      InOut(amount: number): number {\n        if (amount === 0) {\n          return 0;\n        }\n\n        if (amount === 1) {\n          return 1;\n        }\n\n        amount *= 2;\n\n        if (amount < 1) {\n          return (\n            -0.5 *\n            Math.pow(2, 10 * (amount - 1)) *\n            Math.sin((amount - 1.1) * 5 * Math.PI)\n          );\n        }\n\n        return (\n          0.5 *\n            Math.pow(2, -10 * (amount - 1)) *\n            Math.sin((amount - 1.1) * 5 * Math.PI) +\n          1\n        );\n      },\n    },\n  ),\n\n  Back: Object.freeze(\n    <EasingFunctionGroup> {\n      In(amount: number): number {\n        const s = 1.70158;\n        return amount === 1 ? 1 : amount * amount * ((s + 1) * amount - s);\n      },\n      Out(amount: number): number {\n        const s = 1.70158;\n        return amount === 0\n          ? 0\n          : --amount * amount * ((s + 1) * amount + s) + 1;\n      },\n      InOut(amount: number): number {\n        const s = 1.70158 * 1.525;\n        if ((amount *= 2) < 1) {\n          return 0.5 * (amount * amount * ((s + 1) * amount - s));\n        }\n        return 0.5 * ((amount -= 2) * amount * ((s + 1) * amount + s) + 2);\n      },\n    },\n  ),\n\n  Bounce: Object.freeze(\n    <EasingFunctionGroup> {\n      In(amount: number): number {\n        return 1 - Easing.Bounce.Out(1 - amount);\n      },\n      Out(amount: number): number {\n        if (amount < 1 / 2.75) {\n          return 7.5625 * amount * amount;\n        } else if (amount < 2 / 2.75) {\n          return 7.5625 * (amount -= 1.5 / 2.75) * amount + 0.75;\n        } else if (amount < 2.5 / 2.75) {\n          return 7.5625 * (amount -= 2.25 / 2.75) * amount + 0.9375;\n        } else {\n          return 7.5625 * (amount -= 2.625 / 2.75) * amount + 0.984375;\n        }\n      },\n      InOut(amount: number): number {\n        if (amount < 0.5) {\n          return Easing.Bounce.In(amount * 2) * 0.5;\n        }\n        return Easing.Bounce.Out(amount * 2 - 1) * 0.5 + 0.5;\n      },\n    },\n  ),\n\n  pow(power = 4): EasingFunctionGroup {\n    power = power < Number.EPSILON ? Number.EPSILON : power;\n    power = power > 10000 ? 10000 : power;\n    return {\n      In(amount: number): number {\n        return amount ** power;\n      },\n      Out(amount: number): number {\n        return 1 - (1 - amount) ** power;\n      },\n      InOut(amount: number): number {\n        if (amount < 0.5) {\n          return (amount * 2) ** power / 2;\n        }\n        return (1 - (2 - amount * 2) ** power) / 2 + 0.5;\n      },\n    };\n  },\n});\n","// interpolators/array.ts\n\nexport function interpolateArray<T extends number[]>(\n  start: T,\n  end: T,\n  value: number,\n): T {\n  if (value === 0 && start.length !== end.length) {\n    console.warn(\"Array length mismatch.\");\n    return start;\n  }\n  const result = [] as unknown as T;\n  const len = end.length;\n  let i = 0;\n\n  while (i < len) {\n    result.push(start[i] + (end[i] - start[i]) * value);\n    i += 1;\n  }\n  return result;\n}\n","// interpolators/path.ts\nimport type {\n  CubeValues,\n  LineValues,\n  MorphPathArray,\n  MorphPathSegment,\n} from \"../types.ts\";\n\n/**\n * NOTE: Path interpolation only works when both paths have:\n * - Identical command structure (same number and order of M/L/C/Z)\n * - Corresponding coordinates to interpolate\n * Complex morphs (square â†’ triangle) require preprocessing (e.g. KUTE.JS, Flubber)\n * @param start - A starting PathArray value\n * @param end - A starting PathArray value\n * @param t - The progress\n * @returns The interpolated PathArray value\n */\nexport function interpolatePath<T extends MorphPathArray>(\n  start: T,\n  end: T,\n  t: number,\n): T {\n  if (t === 0 && start.length !== end.length) {\n    console.warn(\"Path length mismatch. Returning start path.\");\n    return start;\n  }\n  const result = [] as unknown as T;\n\n  for (let i = 0; i < end.length; i += 1) {\n    const [pathCommand1, values1] = [\n      start[i][0],\n      start[i].slice(1) as LineValues | CubeValues,\n    ];\n    const [pathCommand2, values2] = [\n      end[i][0],\n      end[i].slice(1) as LineValues | CubeValues,\n    ];\n    const commandMismatch = pathCommand1 !== pathCommand2;\n\n    if (t === 0 && (values1.length !== values2.length || commandMismatch)) {\n      console.warn(\n        (commandMismatch ? \"PathCommand\" : \"Params\") +\n          \" mismatch at index: \" +\n          i +\n          \". Returning start path.\",\n      );\n      return start;\n    }\n\n    if (pathCommand1.toUpperCase() === \"Z\") {\n      result.push([\"Z\"]);\n    } else {\n      const resValues = [] as unknown as CubeValues | LineValues;\n\n      for (let j = 0; j < values2.length; j += 1) {\n        resValues.push(values1[j] + (values2[j] - values1[j]) * t);\n      }\n      result.push([pathCommand2, ...resValues] as MorphPathSegment);\n    }\n  }\n\n  return result;\n}\n"],"mappings":"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"}