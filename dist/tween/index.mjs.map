{"version":3,"file":"index.mjs","names":[],"sources":["../../src/Easing.ts","../../src/Util.ts","../../src/extend/array.ts","../../src/extend/path.ts","../../src/extend/object.ts","../../src/extend/transform.ts","../../src/Now.ts","../../src/Runtime.ts","../../src/Tween.ts","../../src/Timeline.ts","../../package.json"],"sourcesContent":["// Easing.ts\nimport type { EasingFunction, EasingFunctionGroup } from \"./types.d.ts\";\n\n/**\n * The Ease class provides a collection of easing functions for use with tween.js.\n */\n\nexport const Easing = Object.freeze({\n  Linear: Object.freeze<EasingFunctionGroup & { None: EasingFunction }>({\n    None(amount: number): number {\n      return amount;\n    },\n    In(amount: number): number {\n      return amount;\n    },\n    Out(amount: number): number {\n      return amount;\n    },\n    InOut(amount: number): number {\n      return amount;\n    },\n  }),\n\n  Quadratic: Object.freeze(\n    <EasingFunctionGroup> {\n      In(amount: number): number {\n        return amount * amount;\n      },\n      Out(amount: number): number {\n        return amount * (2 - amount);\n      },\n      InOut(amount: number): number {\n        if ((amount *= 2) < 1) {\n          return 0.5 * amount * amount;\n        }\n\n        return -0.5 * (--amount * (amount - 2) - 1);\n      },\n    },\n  ),\n\n  Cubic: Object.freeze(\n    <EasingFunctionGroup> {\n      In(amount: number): number {\n        return amount * amount * amount;\n      },\n      Out(amount: number): number {\n        return --amount * amount * amount + 1;\n      },\n      InOut(amount: number): number {\n        if ((amount *= 2) < 1) {\n          return 0.5 * amount * amount * amount;\n        }\n        return 0.5 * ((amount -= 2) * amount * amount + 2);\n      },\n    },\n  ),\n\n  Quartic: Object.freeze(\n    <EasingFunctionGroup> {\n      In(amount: number): number {\n        return amount * amount * amount * amount;\n      },\n      Out(amount: number): number {\n        return 1 - --amount * amount * amount * amount;\n      },\n      InOut(amount: number): number {\n        if ((amount *= 2) < 1) {\n          return 0.5 * amount * amount * amount * amount;\n        }\n\n        return -0.5 * ((amount -= 2) * amount * amount * amount - 2);\n      },\n    },\n  ),\n\n  Quintic: Object.freeze(\n    <EasingFunctionGroup> {\n      In(amount: number): number {\n        return amount * amount * amount * amount * amount;\n      },\n      Out(amount: number): number {\n        return --amount * amount * amount * amount * amount + 1;\n      },\n      InOut(amount: number): number {\n        if ((amount *= 2) < 1) {\n          return 0.5 * amount * amount * amount * amount * amount;\n        }\n\n        return 0.5 * ((amount -= 2) * amount * amount * amount * amount + 2);\n      },\n    },\n  ),\n\n  Sinusoidal: Object.freeze(\n    <EasingFunctionGroup> {\n      In(amount: number): number {\n        return 1 - Math.sin(((1.0 - amount) * Math.PI) / 2);\n      },\n      Out(amount: number): number {\n        return Math.sin((amount * Math.PI) / 2);\n      },\n      InOut(amount: number): number {\n        return 0.5 * (1 - Math.sin(Math.PI * (0.5 - amount)));\n      },\n    },\n  ),\n\n  Exponential: Object.freeze(\n    <EasingFunctionGroup> {\n      In(amount: number): number {\n        return amount === 0 ? 0 : Math.pow(1024, amount - 1);\n      },\n      Out(amount: number): number {\n        return amount === 1 ? 1 : 1 - Math.pow(2, -10 * amount);\n      },\n      InOut(amount: number): number {\n        if (amount === 0) {\n          return 0;\n        }\n\n        if (amount === 1) {\n          return 1;\n        }\n\n        if ((amount *= 2) < 1) {\n          return 0.5 * Math.pow(1024, amount - 1);\n        }\n\n        return 0.5 * (-Math.pow(2, -10 * (amount - 1)) + 2);\n      },\n    },\n  ),\n\n  Circular: Object.freeze(\n    <EasingFunctionGroup> {\n      In(amount: number): number {\n        return 1 - Math.sqrt(1 - amount * amount);\n      },\n      Out(amount: number): number {\n        return Math.sqrt(1 - --amount * amount);\n      },\n      InOut(amount: number): number {\n        if ((amount *= 2) < 1) {\n          return -0.5 * (Math.sqrt(1 - amount * amount) - 1);\n        }\n        return 0.5 * (Math.sqrt(1 - (amount -= 2) * amount) + 1);\n      },\n    },\n  ),\n\n  Elastic: Object.freeze(\n    <EasingFunctionGroup> {\n      In(amount: number): number {\n        if (amount === 0) {\n          return 0;\n        }\n\n        if (amount === 1) {\n          return 1;\n        }\n\n        return (\n          -Math.pow(2, 10 * (amount - 1)) *\n          Math.sin((amount - 1.1) * 5 * Math.PI)\n        );\n      },\n      Out(amount: number): number {\n        if (amount === 0) {\n          return 0;\n        }\n\n        if (amount === 1) {\n          return 1;\n        }\n        return (\n          Math.pow(2, -10 * amount) * Math.sin((amount - 0.1) * 5 * Math.PI) + 1\n        );\n      },\n      InOut(amount: number): number {\n        if (amount === 0) {\n          return 0;\n        }\n\n        if (amount === 1) {\n          return 1;\n        }\n\n        amount *= 2;\n\n        if (amount < 1) {\n          return (\n            -0.5 *\n            Math.pow(2, 10 * (amount - 1)) *\n            Math.sin((amount - 1.1) * 5 * Math.PI)\n          );\n        }\n\n        return (\n          0.5 *\n            Math.pow(2, -10 * (amount - 1)) *\n            Math.sin((amount - 1.1) * 5 * Math.PI) +\n          1\n        );\n      },\n    },\n  ),\n\n  Back: Object.freeze(\n    <EasingFunctionGroup> {\n      In(amount: number): number {\n        const s = 1.70158;\n        return amount === 1 ? 1 : amount * amount * ((s + 1) * amount - s);\n      },\n      Out(amount: number): number {\n        const s = 1.70158;\n        return amount === 0\n          ? 0\n          : --amount * amount * ((s + 1) * amount + s) + 1;\n      },\n      InOut(amount: number): number {\n        const s = 1.70158 * 1.525;\n        if ((amount *= 2) < 1) {\n          return 0.5 * (amount * amount * ((s + 1) * amount - s));\n        }\n        return 0.5 * ((amount -= 2) * amount * ((s + 1) * amount + s) + 2);\n      },\n    },\n  ),\n\n  Bounce: Object.freeze(\n    <EasingFunctionGroup> {\n      In(amount: number): number {\n        return 1 - Easing.Bounce.Out(1 - amount);\n      },\n      Out(amount: number): number {\n        if (amount < 1 / 2.75) {\n          return 7.5625 * amount * amount;\n        } else if (amount < 2 / 2.75) {\n          return 7.5625 * (amount -= 1.5 / 2.75) * amount + 0.75;\n        } else if (amount < 2.5 / 2.75) {\n          return 7.5625 * (amount -= 2.25 / 2.75) * amount + 0.9375;\n        } else {\n          return 7.5625 * (amount -= 2.625 / 2.75) * amount + 0.984375;\n        }\n      },\n      InOut(amount: number): number {\n        if (amount < 0.5) {\n          return Easing.Bounce.In(amount * 2) * 0.5;\n        }\n        return Easing.Bounce.Out(amount * 2 - 1) * 0.5 + 0.5;\n      },\n    },\n  ),\n\n  pow(power = 4): EasingFunctionGroup {\n    power = power < Number.EPSILON ? Number.EPSILON : power;\n    power = power > 10000 ? 10000 : power;\n    return {\n      In(amount: number): number {\n        return amount ** power;\n      },\n      Out(amount: number): number {\n        return 1 - (1 - amount) ** power;\n      },\n      InOut(amount: number): number {\n        if (amount < 0.5) {\n          return (amount * 2) ** power / 2;\n        }\n        return (1 - (2 - amount * 2) ** power) / 2 + 0.5;\n      },\n    };\n  },\n});\n","import type { DeepObject, DeepPartial, TweenProps } from \"./types.d.ts\";\nimport { type Tween } from \"./Tween.ts\";\nimport { type Timeline } from \"./Timeline.ts\";\n\n// Util.ts\nexport const isString = (value: unknown): value is string =>\n  typeof value === \"string\";\n\nexport const isNumber = (value: unknown): value is number =>\n  typeof value === \"number\";\n\nexport const isArray = (value: unknown): value is Array<unknown> =>\n  Array.isArray(value);\n\nexport const isFunction = (value: unknown): value is () => unknown =>\n  typeof value === \"function\";\n\nexport const isObject = (\n  value: unknown,\n): value is Record<string, never> =>\n  value !== null && value !== undefined && typeof value === \"object\" &&\n  Object.getPrototypeOf(value) === Object.prototype;\n\nexport const isPlainObject = (\n  value: unknown,\n): value is Record<string, never> => isObject(value) && !isArray(value);\n\nexport const isDeepObject = (value: unknown): value is DeepObject =>\n  isPlainObject(value) && Object.values(value).some(isPlainObject);\n\nexport const isServer = typeof window === \"undefined\";\n\nconst instanceMethods = [\n  \"play\",\n  \"label\",\n  \"start\",\n  \"stop\",\n  \"pause\",\n  \"resume\",\n  \"reverse\",\n  \"use\",\n  \"clear\",\n  \"from\",\n  \"to\",\n  \"easing\",\n  \"delay\",\n  \"yoyo\",\n  \"repeat\",\n  \"update\",\n  \"repeatDelay\",\n  \"onStart\",\n  \"onUpdate\",\n  \"onComplete\",\n  \"onStop\",\n  \"onRepeat\",\n];\n\n/**\n * SSR helper to speed up UI frameworks render.\n *\n * Why:\n * - skip validation\n * - skip ministore creation\n * - allow free-form configuration for signal based frameworks\n */\nconst dummyInstance: Record<string, typeof dummyMethod> = {};\n// istanbul ignore next @preserve\nconst dummyMethod = () => dummyInstance;\n\nfor (let i = 0; i < instanceMethods.length; i++) {\n  dummyInstance[instanceMethods[i]] = dummyMethod;\n}\n\nexport { dummyInstance };\n\n/**\n * Utility to round numbers to a specified number of decimals.\n * @param n Input number value\n * @param round Number of decimals\n * @returns The rounded number\n */\nexport const roundTo = (n: number, round: number) => {\n  const pow = round >= 1 ? 10 ** round : 1;\n  return round > 0 ? Math.round(n * pow) / pow : Math.round(n);\n};\n\n/**\n * A small utility to deep assign up to one level deep nested objects.\n * This is to prevent breaking reactivity of miniStore.\n *\n * **NOTE** - This doesn't perform ANY check and expects objects to\n * be validated beforehand.\n * @param target The target to assign values to\n * @param source The source object to assign values from\n */\nexport function deepAssign<T extends TweenProps>(\n  target: T,\n  source: T,\n): void {\n  const keys = Object.keys(source) as (keyof T)[];\n  let i = 0;\n  const len = keys.length;\n\n  while (i < len) {\n    const key = keys[i++];\n    const targetVal = target[key];\n    const sourceVal = source[key];\n\n    if (isArray(sourceVal)) {\n      // Handle arrays (number[], TransformArray, MorphPathArray)\n      const targetArr = targetVal as unknown[];\n      let j = 0;\n      const arLen = sourceVal.length;\n\n      while (j < arLen) {\n        const sourceItem = sourceVal[j];\n\n        if (isArray(sourceItem)) {\n          // Nested array (e.g., TransformStep, MorphPathSegment)\n          // if (!isArray(targetArr[j])) {\n          //   targetArr[j] = [];\n          // }\n          const targetItem = targetArr[j] as unknown[];\n          let k = 0;\n          const itemLen = sourceItem.length;\n          while (k < itemLen) {\n            targetItem[k] = sourceItem[k];\n            k++;\n          }\n        } else {\n          // Primitive in array (e.g., number[] like rgb)\n          targetArr[j] = sourceItem;\n        }\n        j++;\n      }\n    } else if (isObject(sourceVal)) {\n      // Handle nested objects (BaseTweenProps)\n      deepAssign(targetVal as never, sourceVal as never);\n    } else {\n      // Primitive value (number)\n      target[key] = sourceVal;\n    }\n  }\n}\n\n/**\n * Creates a clone of a target object / array without its\n * proxy elements / properties, only their values.\n *\n * **NOTE** - The utility is useful to create deep clones as well.\n * @param value An object / array with proxy elements\n * @returns the object / array value without proxy elements\n */\nexport const deproxy = <T>(value: T): T => {\n  if (isArray(value)) {\n    return value.map(deproxy) as T;\n  }\n\n  if (isPlainObject(value)) {\n    const result: Record<string, unknown> = {};\n    for (const key in value) {\n      // istanbul ignore else @preserve\n      if (Object.prototype.hasOwnProperty.call(value, key)) {\n        result[key] = deproxy(value[key]);\n      }\n    }\n    return result as T;\n  }\n\n  return value;\n};\n\n/**\n * Test values validity or their compatibility with the validated ones\n * in the state. This is something we don't want to do in the runtime\n * update loop.\n * @param this The Tween/Timeline instance\n * @param target The target object to validate\n * @param reference The reference state value\n * @returns void\n */\nexport function validateValues<T extends TweenProps>(\n  this: Timeline | Tween,\n  target: Partial<T> | DeepPartial<T>,\n  reference?: T,\n) {\n  const errors = this.getErrors();\n\n  if (!isPlainObject(target) || Object.keys(target).length === 0) {\n    errors.set(\"init\", \"Initialization value is empty or not an object.\");\n    return;\n  }\n\n  const keys = Object.keys(target);\n\n  // skip if from()/to() was used before one another\n  // we don't want to validate props invalidated!\n  if (reference && keys.some((key) => errors.has(key))) {\n    return;\n  }\n\n  // Validate every value\n  let i = 0;\n  while (i < keys.length) {\n    const key = keys[i++];\n    const refValue = reference?.[key];\n    const value = target[key];\n\n    // everything else is either number or not supported\n    if (isNumber(value)) {\n      // no error there\n      // this.removeError(key);\n      continue; // good value\n    }\n\n    if (value === undefined || value === null) {\n      errors.set(key, `Property \"${key}\" is null/undefined.`);\n      continue;\n    }\n\n    if (reference && refValue === undefined) {\n      errors.set(key, `Property \"${key}\" doesn't exist in state yet.`);\n      continue;\n    }\n\n    // allow validators to override default validation behavior\n    const validator = this.getValidator(key);\n    if (validator) {\n      const [valid, reason] = validator(key, value, refValue as never);\n      if (valid) errors.delete(key);\n      else errors.set(key, reason as string);\n      continue;\n    }\n\n    if (reference && isNumber(refValue)) {\n      // istanbul ignore else @preserve\n      if (!isNumber(value)) {\n        errors.set(key, `Property \"${key}\" is not a number.`);\n      }\n      // only validators can revalidate\n      // this case can never be covered\n      // else this.removeError(key);\n\n      continue;\n    }\n\n    // Any value here is either not valid or not supported yet\n    errors.set(\n      key,\n      `Property \"${key}\" of type \"${\n        isArray(value) ? \"array\" : typeof value\n      }\" is not supported yet.`,\n    );\n  }\n  errors.delete(\"init\");\n}\n","// src/extend/array.ts\nimport { isArray, isNumber } from \"../Util.ts\";\nimport { InterpolatorFunction, ValidationResultEntry } from \"../types.ts\";\n\n/**\n * Interpolates two `Array<number>` values.\n *\n * **NOTE**: Values my be validated first!\n * @param target The target `Array<number>` value\n * @param start The start `Array<number>` value\n * @param end The end `Array<number>` value\n * @param t The progress value\n * @returns The interpolated `Array<number>` value.\n */\nexport const interpolateArray: InterpolatorFunction<number[]> = <\n  T extends number[],\n>(\n  target: T,\n  start: T,\n  end: T,\n  t: number,\n) => {\n  const len = end.length;\n  let i = 0;\n\n  while (i < len) {\n    target[i] = start[i] + (end[i] - start[i]) * t;\n    i += 1;\n  }\n\n  return target;\n};\n\n/**\n * Check if a value is a valid array for interpolation\n * @param target The array to check\n * @returns `true` is value is array and all elements are numbers\n */\nexport const isValidArray = <T extends number[]>(\n  target: unknown,\n): target is T => isArray(target) && target.every(isNumber);\n\n/**\n * Check if an array of numbers is compatible with a reference\n * @param target The incoming value `from()` / `to()`\n * @param ref The state reference value\n * @returns [boolean, reason] tuple when arrays are compatible or\n */\nexport const validateArray = <T extends number[]>(\n  propName: string,\n  target: unknown,\n  ref?: T,\n): ValidationResultEntry => {\n  // istanbul ignore if @preserve\n  if (!isArray(target)) {\n    return [false, `Property \"${String(propName)}\" is not Array.`];\n  }\n  // istanbul ignore if @preserve\n  if (!isValidArray(target)) {\n    return [\n      false,\n      `Property \"${String(propName)}\" is not a valid Array<number>.`,\n    ];\n  }\n\n  if (ref && ref.length !== target.length) {\n    return [\n      false,\n      `Property \"${\n        String(propName)\n      }\" is expecting an array of ${ref.length} numbers.`,\n    ];\n  }\n\n  return [true];\n};\n\n/**\n * Config for .use(propName, arrayConfig)\n */\nexport const arrayConfig = {\n  interpolate: interpolateArray,\n  validate: validateArray,\n};\n","// src/extend/path.ts\nimport { isArray, isNumber } from \"../Util.ts\";\n\nimport type {\n  InterpolatorFunction,\n  MorphPathArray,\n  MorphPathSegment,\n  PathLike,\n  ValidationResultEntry,\n} from \"../types.ts\";\n\nimport { roundTo } from \"../Util.ts\";\n\n/**\n * Iterates a `PathArray` and concatenates the values into a string to return it.\n * **NOTE**: Segment values are rounded to 4 decimals by default.\n * @param path A source PathArray\n * @param round An optional parameter to round segment values to a number of decimals\n * @returns A path string\n */\nexport function pathToString(path: MorphPathArray, round = 4) {\n  const pathLen = path.length;\n  let segment = path[0];\n  let result = \"\";\n  let i = 0;\n  let segLen = 0;\n\n  while (i < pathLen) {\n    segment = path[i++];\n    segLen = segment.length;\n    result += segment[0];\n\n    let j = 1;\n\n    while (j < segLen) {\n      result += roundTo(segment[j++] as number, round);\n      if (j !== segLen) result += \" \";\n    }\n  }\n\n  return result;\n}\n\n/**\n * Interpolate PathArray values.\n * **NOTE**: these values must be validated first! Check validatePath for more info.\n * @param target - The target PathArray value\n * @param start - A starting PathArray value\n * @param end - An ending PathArray value\n * @param t - The progress value\n * @returns The interpolated PathArray value\n */\nexport const interpolatePath: InterpolatorFunction<MorphPathSegment[]> = <\n  T extends MorphPathSegment[],\n>(\n  target: T,\n  start: T,\n  end: T,\n  t: number,\n): T => {\n  const segCount = end.length;\n  let i = 0;\n\n  while (i < segCount) {\n    const targetSeg = target[i];\n    const startSeg = start[i];\n    const endSeg = end[i];\n\n    if (targetSeg[0] === \"Z\") {\n      i++;\n      continue;\n    } else if (targetSeg[0] === \"C\") {\n      targetSeg[1] = startSeg[1]! + (endSeg[1]! - startSeg[1]!) * t;\n      targetSeg[2] = startSeg[2]! + (endSeg[2]! - startSeg[2]!) * t;\n      targetSeg[3] = startSeg[3]! + (endSeg[3]! - startSeg[3]!) * t;\n      targetSeg[4] = startSeg[4]! + (endSeg[4]! - startSeg[4]!) * t;\n      targetSeg[5] = startSeg[5]! + (endSeg[5]! - startSeg[5]!) * t;\n      targetSeg[6] = startSeg[6]! + (endSeg[6]! - startSeg[6]!) * t;\n    } else { // M / L\n      targetSeg[1] = startSeg[1]! + (endSeg[1]! - startSeg[1]!) * t;\n      targetSeg[2] = startSeg[2]! + (endSeg[2]! - startSeg[2]!) * t;\n    }\n    i++;\n  }\n\n  return target as T;\n};\n\nconst supportedPathCommands = [\"M\", \"L\", \"C\", \"Z\"] as const;\n\n/**\n * Check if an array of arrays is potentially a PathArray\n * @param target The incoming value `constructor()` `from()` / `to()`\n * @returns `true` when array is potentially a PathArray\n */\nexport const isPathLike = (\n  value: unknown,\n): value is PathLike =>\n  isArray(value) &&\n  value.some((seg) =>\n    isArray(seg) && supportedPathCommands.includes(seg[0] as never)\n  );\n\n/**\n * Check if an array of arrays is a valid PathArray for interpolation\n * @param target The incoming value `from()` / `to()`\n * @returns `true` when array is valid\n */\nexport const isValidPath = (value: unknown): value is MorphPathArray =>\n  isPathLike(value) && value.length > 1 && value.every(isArray) &&\n  value.every(([cmd, ...values]) =>\n    supportedPathCommands.includes(cmd as MorphPathSegment[0]) && (\n      ([\"M\", \"L\"].includes(cmd as MorphPathSegment[0]) &&\n        (values as number[]).length === 2 &&\n        values.every(isNumber)) ||\n      (\"C\" === cmd && (values as number[]).length === 6 &&\n        values.every(isNumber)) ||\n      (\"Z\" === cmd && (values as number[]).length === 0)\n    )\n  );\n\n/**\n * Validate a PathArray and check if it's compatible with a reference.\n *\n * **NOTE**: Path interpolation only works when both paths have:\n * - Identical segments structure (same number and order of M/L/C/Z)\n * - Corresponding coordinates to interpolate\n * Complex morphs require preprocessing (e.g. KUTE.js, Flubber)\n *\n * @example\n * // simple shapes\n * const linePath1 = [[\"M\", 0, 0],[\"L\", 50, 50]]\n * const linePath2 = [[\"M\",50,50],[\"L\",150,150]]\n * const curvePath1 = [[\"M\", 0, 0],[\"C\",15,15, 35, 35, 50, 50]]\n * const curvePath2 = [[\"M\",50,50],[\"C\",50,50,100,100,150,150]]\n *\n * // closed shapes\n * const closedLinePath1 = [[\"M\", 0, 0],[\"L\", 50, 50],[\"Z\"]]\n * const closedLinePath2 = [[\"M\",50,50],[\"L\",150,150],[\"Z\"]]\n * const closedCurvePath1 = [[\"M\", 0, 0],[\"C\",15,15, 35, 35, 50, 50],[\"Z\"]]\n * const closedCurvePath2 = [[\"M\",50,50],[\"C\",50,50,100,100,150,150],[\"Z\"]]\n *\n * // composit shapes (multi-path)\n * const compositPath1 = [\n *  [\"M\", 0, 0],[\"L\",50,50],\n *  [\"M\",50,50],[\"C\",50,50,100,100,150,150],\n * ]\n * const compositPath2 = [\n *  [\"M\",50,50],[\"L\",150,150],\n *  [\"M\", 0, 0],[\"C\", 15, 15,35,35,50,50],\n * ]\n *\n * @param target The incoming value `from()` / `to()`\n * @param ref The state reference value\n * @returns `true` when arrays are compatible or a reason why not\n */\nexport const validatePath = <T extends MorphPathArray>(\n  propName: string,\n  target: unknown,\n  ref?: T,\n): ValidationResultEntry => {\n  // ref is state[prop] and is already validated on initialization\n  if (!isValidPath(target)) {\n    return [false, `Property \"${propName}\" is not a valid PathArray.`];\n  }\n\n  if (ref) {\n    if (ref.length !== target.length) {\n      return [\n        false,\n        `Property \"${propName}\" is expecting an array of ${ref.length} path segments, got ${target.length}.`,\n      ];\n    }\n\n    let i = 0;\n    const len = ref.length;\n    while (i < len) {\n      const refSeg = ref[i];\n      const targetSeg = target[i];\n      const refCmd = refSeg[0];\n      const targetCmd = targetSeg[0];\n      const refLen = refSeg.length;\n      const targetLen = targetSeg.length;\n\n      if (refCmd !== targetCmd || refLen !== targetLen) {\n        return [\n          false,\n          `Property \"${propName}\" mismatch at index ${i}. ` +\n          `Segments don't match:\\n` +\n          `> segment: \"[${targetCmd}, ${targetSeg.slice(1)}]\"\\n` +\n          `> reference: \"[${refCmd}, ${refSeg.slice(1)}]\"`,\n        ];\n      }\n      i++;\n    }\n  }\n\n  return [true];\n};\n\n/**\n * Config for .use(propName, pathArrayConfig)\n */\nexport const pathArrayConfig = {\n  interpolate: interpolatePath,\n  validate: validatePath,\n};\n","// src/extend/object.ts\nimport type {\n  BaseTweenProps,\n  InterpolatorFunction,\n  ValidationResultEntry,\n} from \"../types.ts\";\nimport { isNumber, isPlainObject } from \"../Util.ts\";\n\n/**\n * Single-level object interpolator\n * **Note**: values must be validated first!\n *\n * Input: { scale: { x: 1, y: 1 } }\n * Output: interpolated flat object with same structure\n * @param target The target value of the object\n * @param start The start value of the object\n * @param end The end value of the object\n * @param t The progress value\n * @returns The interpolated flat object with same structure.\n */\nexport const interpolateObject: InterpolatorFunction<BaseTweenProps> = <\n  T extends BaseTweenProps,\n>(\n  target: T,\n  start: T,\n  end: T,\n  t: number,\n): T => {\n  // Iterate over end keys (we only interpolate what's in end)\n  const keys = Object.keys(end) as (keyof T)[];\n  let i = 0;\n\n  while (i < keys.length) {\n    const key = keys[i++];\n    const endVal = end[key];\n    const startVal = start[key];\n\n    target[key] = (startVal + (endVal - startVal) * t) as T[keyof T];\n  }\n\n  return target;\n};\n\n/**\n * Validate a simple plain object and compare its compatibility with a reference object.\n * @param propName The property name to which this object belongs to\n * @param target The target object itself\n * @param ref A reference object to compare our target to\n * @returns A [boolean, string?] tuple which represents [validity, \"reason why not valid\"]\n */\nexport const validateObject = (\n  propName: string,\n  target: unknown,\n  ref?: BaseTweenProps,\n): ValidationResultEntry => {\n  if (!isPlainObject(target)) {\n    return [false, `Property \"${propName}\" must be a plain object.`];\n  }\n\n  const keys = Object.keys(target);\n  let i = 0;\n  const iLen = keys.length;\n\n  while (i < iLen) {\n    const key = keys[i++];\n    const value = target[key];\n\n    if (value === null || value === undefined) {\n      return [\n        false,\n        `Property \"${key}\" from \"${propName}\" is null/undefined.`,\n      ];\n    }\n\n    // We never want to go down that route\n    // if (isPlainObject(value)) {}\n\n    if (!isNumber(value)) {\n      return [\n        false,\n        `Property \"${key}\" from \"${propName}\" must be a number.` +\n        `${\n          isPlainObject(value)\n            ? \" Deeper nested objects are not supported.\"\n            : ` Unsupported value: \"${typeof value}\".`\n        }`,\n      ];\n    }\n\n    if (ref) {\n      if (ref[key] === undefined) {\n        return [\n          false,\n          `Property \"${key}\" in \"${propName}\" doesn't exist in the reference object.`,\n        ];\n      }\n    }\n  }\n\n  return [true];\n};\n\n/**\n * Config for .use(propName, objectConfig)\n */\nexport const objectConfig = {\n  interpolate: interpolateObject,\n  validate: validateObject,\n};\n","// src/extend/transform.ts\nimport type {\n  InterpolatorFunction,\n  TransformArray,\n  TransformLike,\n  TransformStep,\n  TransformStepInternal,\n  ValidationResultEntry,\n  Vec3,\n} from \"../types.ts\";\nimport { isArray, isNumber } from \"../Util.ts\";\n\n/**\n * Returns a valid CSS transform string either with transform functions (Eg.: `translate(15px) rotate(25deg)`)\n * or `matrix(...)` / `matrix3d(...)`.\n * When the `toMatrix` parameter is `true` it will create a DOMMatrix instance, apply transform\n * steps and return a `matrix(...)` or `matrix3d(...)` string value.\n * @param steps An array of TransformStep\n * @param toMatrix An optional parameter to modify the function output\n * @returns The valid CSS transform string value\n */\nexport const transformToString = (steps: TransformStep[], toMatrix = false) => {\n  if (toMatrix) {\n    const matrix = new DOMMatrix();\n    const len = steps.length;\n    let i = 0;\n\n    while (i < len) {\n      const step = steps[i++];\n\n      switch (step[0]) {\n        case \"perspective\": {\n          const m2 = new DOMMatrix();\n          m2.m34 = -1 / step[1];\n          matrix.multiplySelf(m2);\n          break;\n        }\n        case \"translate\": {\n          matrix.translateSelf(step[1], step[2] || 0, step[3] || 0);\n          break;\n        }\n        case \"rotate\": {\n          matrix.rotateSelf(step[1], step[2] || 0, step[3] || 0);\n          break;\n        }\n        case \"rotateAxisAngle\": {\n          matrix.rotateAxisAngleSelf(step[1], step[2], step[3], step[4]);\n          break;\n        }\n        case \"scale\": {\n          matrix.scaleSelf(step[1], step[2] || 1, step[3] || 1);\n          break;\n        }\n        case \"skewX\": {\n          matrix.skewXSelf(step[1]);\n          break;\n        }\n        case \"skewY\": {\n          matrix.skewYSelf(step[1]);\n          break;\n        }\n      }\n    }\n\n    return matrix.toString();\n  }\n  // Return CSS transform string\n  const len = steps.length;\n  let i = 0;\n  let stringOutput = \"\";\n\n  while (i < len) {\n    const step = steps[i++];\n\n    switch (step[0]) {\n      case \"perspective\": {\n        stringOutput += ` perspective(${step[1]}px)`;\n        break;\n      }\n      case \"translate\": {\n        stringOutput += ` translate3d(${step[1]}px, ${step[2] || 0}px, ${\n          step[3] || 0\n        }px)`;\n        break;\n      }\n      case \"rotate\": {\n        const [rx, ry, rz] = step.slice(1) as Vec3;\n\n        if (typeof rx === \"number\" && ry === undefined && rz === undefined) {\n          stringOutput += ` rotate(${step[1]}deg)`;\n        } else {\n          stringOutput += ` rotateX(${step[1]}deg)`;\n          // istanbul ignore else @preserve\n          if (step[2] !== undefined) stringOutput += ` rotateY(${step[2]}deg)`;\n          // istanbul ignore else @preserve\n          if (step[3] !== undefined) stringOutput += ` rotateZ(${step[3]}deg)`;\n        }\n        break;\n      }\n      case \"rotateAxisAngle\": {\n        stringOutput += ` rotate3d(${step[1]}, ${step[2]}, ${step[3]}, ${\n          step[4]\n        }deg)`;\n        break;\n      }\n      case \"scale\": {\n        stringOutput += ` scale(${step[1]}, ${step[2] || step[1]}, ${\n          step[3] || 1\n        })`;\n        break;\n      }\n      case \"skewX\": {\n        stringOutput += ` skewX(${step[1]}deg)`;\n        break;\n      }\n      case \"skewY\": {\n        stringOutput += ` skewY(${step[1]}deg)`;\n        break;\n      }\n    }\n  }\n\n  return stringOutput.slice(1);\n};\n\n/**\n * Convert euler rotation to axis angle.\n * All values are degrees.\n * @param x rotateX value\n * @param y rotateY value\n * @param z rotateZ value\n * @returns The axis angle tuple [vectorX, vectorY, vectorZ, angle]\n */\nexport const eulerToAxisAngle = (\n  x: number,\n  y: number,\n  z: number,\n): [number, number, number, number] => {\n  // Convert to quaternion first\n  const quat = eulerToQuaternion(x, y, z);\n\n  // Then convert quaternion to axis-angle\n  return quaternionToAxisAngle(quat);\n};\n\n/**\n * Convert euler rotation tuple to quaternion.\n * All values are degrees.\n * @param x The rotateX value\n * @param y The rotateY value\n * @param z The rotateZ value\n * @returns The rotation quaternion\n */\nconst eulerToQuaternion = (\n  x: number,\n  y: number,\n  z: number,\n): [number, number, number, number] => {\n  const cx = Math.cos(x / 2);\n  const sx = Math.sin(x / 2);\n  const cy = Math.cos(y / 2);\n  const sy = Math.sin(y / 2);\n  const cz = Math.cos(z / 2);\n  const sz = Math.sin(z / 2);\n\n  return [\n    cx * cy * cz + sx * sy * sz,\n    sx * cy * cz - cx * sy * sz,\n    cx * sy * cz + sx * cy * sz,\n    cx * cy * sz - sx * sy * cz,\n  ];\n};\n\n/**\n * Convert euler rotation tuple to axis angle.\n * All values are degrees.\n * @param q The rotation quaternion\n * @returns The axis angle tuple [vectorX, vectorY, vectorZ, angle]\n */\nconst quaternionToAxisAngle = (\n  q: [number, number, number, number],\n): [number, number, number, number] => {\n  const [w, x, y, z] = q;\n\n  // Normalize\n  const len = Math.sqrt(x * x + y * y + z * z);\n\n  if (len < 0.0001) {\n    // No rotation\n    return [0, 0, 1, 0];\n  }\n\n  const angle = 2 * Math.acos(Math.max(-1, Math.min(1, w)));\n\n  return [x / len, y / len, z / len, angle];\n};\n\n/**\n * Interpolator: takes start/end arrays of `TransformStep`s → returns interpolated `TransformStep`s.\n * **Note** - Like `PathArray`, these values are required to have same length and structure.\n * @example\n * const a1: TransformArray = [\n *  [\"translate\", 0, 0],              // [translateX, translateY]\n *  [\"rotate\", 0],                    // [rotateZ]\n *  [\"rotate\", 0, 0],                 // [rotateX, rotateY]\n *  [\"rotateAxisAngle\", 0, 0, 0, 0],  // [originX, originY, originZ, angle]\n *  [\"scale\", 1],                     // [scale]\n *  [\"scale\", 1, 1],                  // [scaleX, scaleY]\n *  [\"perspective\", 800],             // [length]\n * ];\n * const a2: TransformArray = [\n *  [\"translate\", 50, 50],\n *  [\"rotate\", 45],\n *  [\"rotate\", 45, 45],\n *  [\"rotateAxisAngle\", 1, 0, 0, 45],\n *  [\"scale\", 1.5],\n *  [\"scale\", 1.5, 1.2],\n *  [\"perspective\", 400],\n * ];\n *\n * @param target The target `TransformArray`\n * @param start The start `TransformArray`\n * @param end The end `TransformArray`\n * @param t The progress value\n * @returns The interpolated `TransformArray`\n */\nexport const interpolateTransform: InterpolatorFunction<TransformStep[]> = <\n  T extends TransformStepInternal[],\n>(\n  target: T,\n  start: T,\n  end: T,\n  t: number,\n): T => {\n  const len = end.length;\n  let i = 0;\n\n  while (i < len) {\n    const targetStep = target[i];\n    const startStep = start[i];\n    const endStep = end[i];\n\n    switch (targetStep[0]) {\n      case \"translate\":\n      case \"rotate\":\n      case \"scale\":\n      case \"rotateAxisAngle\":\n        targetStep[1] = startStep[1] + (endStep[1] - startStep[1]) * t;\n\n        typeof endStep[2] === \"number\" &&\n          (targetStep[2] = startStep[2]! + (endStep[2]! - startStep[2]!) * t);\n\n        typeof endStep[3] === \"number\" &&\n          (targetStep[3] = startStep[3]! + (endStep[3]! - startStep[3]!) * t);\n\n        typeof endStep[4] === \"number\" &&\n          (targetStep[4] = startStep[4]! + (endStep[4]! - startStep[4]!) * t);\n\n        break;\n      case \"skewX\":\n      case \"skewY\":\n      case \"perspective\":\n        targetStep[1] = startStep[1] + (endStep[1] - startStep[1]) * t;\n\n        break;\n    }\n    i++;\n  }\n\n  return target as T;\n};\n\nconst supportedTransform = [\n  \"perspective\",\n  \"translate\",\n  \"rotate\",\n  \"rotateAxisAngle\",\n  \"scale\",\n  \"skewX\",\n  \"skewY\",\n] as const;\n\n/**\n * Check if an array of arrays is potentially a TransformArray\n * @param target The incoming value `constructor()` `from()` / `to()`\n * @returns `true` when array is potentially a PathArray\n */\nexport const isTransformLike = (value: unknown): value is TransformLike =>\n  isArray(value) &&\n  value.some(\n    (step) => isArray(step) && supportedTransform.includes(step[0] as never),\n  );\n\n/**\n * Check if an array of arrays is a valid TransformArray for interpolation\n * @param target The incoming value `from()` / `to()`\n * @returns `true` when array is valid\n */\nexport const isValidTransformArray = (\n  value: unknown,\n): value is TransformArray =>\n  isTransformLike(value) &&\n  value.every(\n    ([fn, ...values]) =>\n      supportedTransform.includes(fn as TransformStep[0]) &&\n      (([\"translate\", \"rotate\", \"scale\"].includes(fn as TransformStep[0]) &&\n        values.length > 0 &&\n        values.length <= 3 &&\n        values.every(isNumber)) ||\n        (\"rotateAxisAngle\" === fn &&\n          (values as number[]).length === 4 &&\n          values.every(isNumber)) ||\n        ([\"skewX\", \"skewY\", \"perspective\"].includes(fn as string) &&\n          (values as number[]).length === 1 &&\n          isNumber((values as number[])[0]))),\n  );\n\n/**\n * Validator for TransformArray\n * Checks structure + number types + optional param counts\n */\nexport const validateTransform = (\n  propName: string,\n  target: unknown,\n  ref?: TransformArray,\n): ValidationResultEntry => {\n  if (!isValidTransformArray(target)) {\n    return [false, `Property \"${propName}\" must be an array of TransformStep.`];\n  }\n\n  if (ref) {\n    if (ref.length !== target.length) {\n      return [\n        false,\n        `Property \"${propName}\" is expecting an array of ${ref.length} transform steps, got ${target.length}.`,\n      ];\n    }\n\n    let i = 0;\n    const len = target.length;\n\n    while (i < len) {\n      const step = target[i] as [string, ...Vec3];\n      const refStep = ref[i] as [string, ...Vec3];\n      const fn = step[0];\n      const fnRef = refStep[0];\n\n      // istanbul ignore else @preserve\n      if (refStep) {\n        if (fnRef !== fn || refStep.length !== step.length) {\n          return [\n            false,\n            `Property \"${propName}\" mismatch at index ${i}\":\\n` +\n            `> step: [\"${fn}\", ${step.slice(1)}]\\n` +\n            `> reference: [\"${fnRef}\", ${refStep.slice(1)}]`,\n          ];\n        }\n      }\n      i++;\n    }\n  }\n\n  return [true];\n};\n\n/**\n * Config for .use(\"transform\", transformConfig)\n */\nexport const transformConfig = {\n  interpolate: interpolateTransform,\n  validate: validateTransform,\n};\n","let _nowFunc = () => globalThis.performance.now();\n\nexport const now = (): number => {\n  return _nowFunc();\n};\n\nexport function setNow(nowFunction: typeof _nowFunc) {\n  _nowFunc = nowFunction;\n}\n","// Runtime.ts\nimport type { AnimationItem, TweenProps } from \"./types.d.ts\";\nimport { now } from \"./Now.ts\";\n\n/**\n * The runtime queue\n */\nexport const Queue: (AnimationItem | null)[] = new Array(10000).fill(null);\n\nlet rafID = 0;\nlet queueLength = 0;\n\n/**\n * The hot update loop updates all items in the queue,\n * and stops automatically when there are no items left.\n * @param t execution time (performance.now)\n */\nexport function Runtime(t = now()) {\n  let i = 0;\n  let writeIdx = 0;\n\n  while (i < queueLength) {\n    const item = Queue[i++];\n    if (item && item.update(t)) {\n      Queue[writeIdx++] = item;\n    }\n  }\n\n  queueLength = writeIdx;\n\n  if (queueLength === 0) {\n    cancelAnimationFrame(rafID);\n    rafID = 0;\n  } else {\n    rafID = requestAnimationFrame(Runtime);\n  }\n}\n\n/**\n * Add a new item to the update loop.\n * If it's the first item, it will also start the update loop.\n * @param newItem Tween / Timeline\n */\nexport function addToQueue<T extends TweenProps>(\n  newItem: AnimationItem<T>,\n): void {\n  const item = newItem as unknown as AnimationItem<never>;\n  Queue[queueLength++] = item;\n\n  if (!rafID) Runtime();\n}\n\n/**\n * Remove item from the update loop.\n * @param newItem Tween / Timeline\n */\nexport function removeFromQueue<T extends TweenProps>(\n  removedItem: AnimationItem<T>,\n): void {\n  const idx = Queue.indexOf(removedItem as unknown as AnimationItem<never>);\n  // istanbul ignore else @preserve\n  if (idx !== -1) {\n    Queue[idx] = null;\n  }\n}\n","// Tween.ts\nimport type {\n  DeepPartial,\n  EasingFunction,\n  InterpolatorFunction,\n  PropConfig,\n  TweenCallback,\n  TweenProps,\n  TweenRuntime,\n  TweenUpdateCallback,\n  ValidationFunction,\n} from \"./types.d.ts\";\nimport {\n  deepAssign,\n  deproxy,\n  isArray,\n  isObject,\n  validateValues,\n} from \"./Util.ts\";\nimport { addToQueue, removeFromQueue } from \"./Runtime.ts\";\nimport { now } from \"./Now.ts\";\n\n/**\n * Lightweight tween engine for interpolating values over time.\n * Supports numbers and via extensions it enxtends to arrays\n * (e.g. RGB, points), nested objects, and SVG path morphing.\n *\n * @template T - The type of the target object (usually a plain object with numeric properties)\n *\n * @example\n * ```ts\n * const tween = new Tween({ x: 0, opacity: 1 })\n *   .to({ x: 300, opacity: 0 })\n *   .duration(1.5)\n *   .easing(Easing.Elastic.Out)\n *   .start();\n * ```\n *\n * @param initialValues The initial values object\n */\nexport class Tween<T extends TweenProps = TweenProps> {\n  state: T;\n  private _state: T;\n  private _startIsSet = false;\n  private _repeat = 0;\n  private _yoyo = false;\n  private _reversed = false;\n  private _initialRepeat = 0;\n  private _startFired = false;\n  private _propsStart: Partial<T> = {};\n  private _propsEnd: Partial<T> = {};\n  private _isPlaying = false;\n  private _duration = 1000;\n  private _delay = 0;\n  private _pauseStart = 0;\n  private _repeatDelay = 0;\n  private _startTime: number = 0;\n  private _errors = new Map<string | \"init\", string>();\n  private _interpolators = new Map<string | keyof T, InterpolatorFunction>();\n  private _validators = new Map<string | keyof T, ValidationFunction>();\n  private _easing: EasingFunction = (t) => t;\n  private _onUpdate?: TweenUpdateCallback<T>;\n  private _onComplete?: TweenCallback<T>;\n  private _onStart?: TweenCallback<T>;\n  private _onStop?: TweenCallback<T>;\n  private _onPause?: TweenCallback<T>;\n  private _onResume?: TweenCallback<T>;\n  private _onRepeat?: TweenCallback<T>;\n  private _runtime: (TweenRuntime<T>)[] = [];\n  /**\n   * Creates a new Tween instance.\n   * @param initialValues - The initial state of the animated object\n   */\n  constructor(initialValues: T) {\n    // we must initialize state to allow isValidState to work from here\n    this.state = {} as T;\n    validateValues.call(this as unknown as Tween, initialValues);\n    if (this._errors.size) {\n      // we temporarily store initialValues reference here\n      this._state = initialValues;\n    } else {\n      // or set values right away\n      this.state = initialValues;\n      this._state = deproxy(initialValues);\n    }\n\n    return this;\n  }\n\n  // GETTERS FIRST\n  /**\n   * A boolean that returns `true` when tween is playing.\n   */\n  get isPlaying(): boolean {\n    return this._isPlaying;\n  }\n\n  /**\n   * A boolean that returns `true` when tween is paused.\n   */\n  get isPaused(): boolean {\n    return this._pauseStart > 0;\n  }\n\n  /**\n   * A boolean that returns `true` when initial values are valid.\n   */\n  get isValidState(): boolean {\n    return Object.keys(this.state).length > 0;\n  }\n\n  /**\n   * A boolean that returns `true` when all values are valid.\n   */\n  get isValid(): boolean {\n    return this._errors.size === 0;\n  }\n\n  /**\n   * Returns the configured duration in seconds.\n   */\n  getDuration() {\n    return this._duration / 1000;\n  }\n\n  /**\n   * Returns the total duration in seconds. It's calculated as a sum of\n   * the delay, duration multiplied by repeat value, repeat delay multiplied\n   * by repeat value.\n   */\n  get totalDuration() {\n    const repeat = this._initialRepeat;\n    return (\n      this._delay +\n      this._duration * (repeat + 1) +\n      this._repeatDelay * repeat\n    ) / 1000;\n  }\n\n  /**\n   * Returns the validator configured for a given property.\n   */\n  getValidator(propName: string) {\n    return this._validators.get(propName);\n  }\n\n  /**\n   * Returns the errors Map, mainly used by external validators.\n   */\n  getErrors() {\n    return this._errors;\n  }\n\n  /**\n   * Starts the tween (adds it to the global update loop).\n   * Triggers `onStart` if set.\n   * @param time - Optional explicit start time (defaults to `now()`)\n   * @param overrideStart - If true, resets starting values even if already set\n   * @returns this\n   */\n  start(time = now(), overrideStart = false) {\n    if (this._isPlaying) return this;\n    if (this._pauseStart) return this.resume();\n    if (!this.isValid) {\n      this._report();\n      return this;\n    }\n    // micro-optimization - don't reset state if never started\n    if (this._startTime && !overrideStart) this._resetState();\n\n    // istanbul ignore else @preserve\n    if (!this._startIsSet || /* istanbul ignore next */ overrideStart) {\n      this._startIsSet = true;\n\n      this._setProps(\n        this.state,\n        this._propsStart,\n        this._propsEnd,\n        overrideStart,\n      );\n    }\n    this._isPlaying = true;\n    this._startTime = time;\n    this._startTime += this._delay;\n\n    addToQueue(this);\n    return this;\n  }\n\n  /**\n   * Starts the tween from current values.\n   * @param time - Optional explicit start time (defaults to `now()`)\n   * @returns this\n   */\n  startFromLast(time = now()) {\n    return this.start(time, true);\n  }\n\n  /**\n   * Immediately stops the tween and removes it from the update loop.\n   * Triggers `onStop` if set.\n   * @returns this\n   */\n  stop() {\n    if (!this._isPlaying) return this;\n    removeFromQueue(this);\n    this._isPlaying = false;\n    this._repeat = this._initialRepeat;\n    this._reversed = false;\n\n    this._onStop?.(this.state);\n    return this;\n  }\n\n  /**\n   * Reverses playback direction and mirrors current time position.\n   * @returns this\n   */\n  reverse(): this {\n    // istanbul ignore next @preserve\n    if (!this._isPlaying) return this;\n\n    const currentTime = now();\n    const elapsed = currentTime - this._startTime;\n    this._startTime = currentTime - (this._duration - elapsed);\n    this._reversed = !this._reversed;\n\n    // istanbul ignore else @preserve\n    if (this._initialRepeat > 0) {\n      this._repeat = this._initialRepeat - this._repeat;\n    }\n\n    return this;\n  }\n\n  /**\n   * Pause playback and capture the pause time.\n   * @param time - Time of pause\n   * @returns this\n   */\n  pause(time = now()): this {\n    if (!this._isPlaying) return this;\n\n    this._pauseStart = time;\n    this._isPlaying = false;\n    this._onPause?.(this.state);\n\n    return this;\n  }\n\n  /**\n   * Resume playback and reset the pause time.\n   * @param time - Time of pause\n   * @returns this\n   */\n  resume(time = now()): this {\n    if (!this._pauseStart) return this;\n\n    this._startTime += time - this._pauseStart;\n    this._pauseStart = 0;\n    this._isPlaying = true;\n    this._onResume?.(this.state);\n\n    addToQueue(this);\n\n    return this;\n  }\n\n  /**\n   * Sets the starting values for properties.\n   * @param startValues - Partial object with starting values\n   * @returns this\n   */\n  from(startValues: Partial<T> | DeepPartial<T>) {\n    if (!this.isValidState || this.isPlaying) return this;\n\n    this._evaluate(startValues);\n    if (this.isValid) {\n      Object.assign(this._propsStart, startValues);\n      this._startIsSet = false;\n    }\n\n    return this;\n  }\n\n  /**\n   * Sets the ending values for properties.\n   * @param endValues - Partial object with target values\n   * @returns this\n   */\n  to(endValues: Partial<T> | DeepPartial<T>) {\n    if (!this.isValidState || this.isPlaying) return this;\n\n    this._evaluate(endValues);\n    if (this.isValid) {\n      this._propsEnd = endValues as T;\n      this._startIsSet = false;\n    }\n\n    return this;\n  }\n\n  /**\n   * Sets the duration of the tween in seconds.\n   * Internally it's converted to milliseconds.\n   * @param duration - Time in seconds\n   * @default 1 second\n   * @returns this\n   */\n  duration(seconds = 1) {\n    this._duration = seconds * 1000;\n    return this;\n  }\n\n  /**\n   * Sets the delay in seconds before the tween starts.\n   * Internally it's converted to milliseconds.\n   * @param delay - Time in seconds\n   * @default 0 seconds\n   * @returns this\n   */\n  delay(seconds = 0) {\n    this._delay = seconds * 1000;\n    return this;\n  }\n\n  /**\n   * Sets how many times to repeat.\n   * @param times - How many times to repeat\n   * @default 0 times\n   * @returns this\n   */\n  repeat(times = 0) {\n    this._repeat = times;\n    this._initialRepeat = times;\n    return this;\n  }\n\n  /**\n   * Sets a number of seconds to delay the animation\n   * after each repeat.\n   * @param amount - How many seconds to delay\n   * @default 0 seconds\n   * @returns this\n   */\n  repeatDelay(amount = 0) {\n    this._repeatDelay = amount * 1000;\n    return this;\n  }\n\n  /**\n   * Sets to tween from end to start values.\n   * The easing is also goes backwards.\n   * This requires repeat value of at least 1.\n   * @param yoyo - When `true` values are reversed on every uneven repeat\n   * @default false\n   * @returns this\n   */\n  yoyo(yoyo = false) {\n    this._yoyo = yoyo;\n    return this;\n  }\n\n  /**\n   * Sets the easing function.\n   * @param easing - Function that maps progress [0,1] → eased progress [0,1]\n   * @default linear\n   * @returns this\n   */\n  easing(easing: EasingFunction = (t: number) => t) {\n    this._easing = easing;\n    return this;\n  }\n\n  /**\n   * Registers a callback fired when `.start()` is called.\n   * @param callback - Receives state at start time\n   * @returns this\n   */\n  onStart(callback: TweenCallback<T>) {\n    this._onStart = callback;\n    return this;\n  }\n\n  /**\n   * Registers a callback fired on every frame.\n   * @param callback - Receives current state, elapsed (0–1)\n   * @returns this\n   */\n  onUpdate(callback?: TweenUpdateCallback<T>) {\n    this._onUpdate = callback;\n    return this;\n  }\n\n  /**\n   * Registers a callback fired when the tween reaches progress = 1.\n   * @param callback - Receives final state\n   * @returns this\n   */\n  onComplete(callback: TweenCallback<T>) {\n    this._onComplete = callback;\n    return this;\n  }\n\n  /**\n   * Registers a callback fired when `.stop()` is called.\n   * @param callback - Receives state at stop time\n   * @returns this\n   */\n  onStop(callback: TweenCallback<T>) {\n    this._onStop = callback;\n    return this;\n  }\n\n  /**\n   * Registers a callback fired when `pause()` was called.\n   */\n  onPause(cb: TweenCallback<T>) {\n    this._onPause = cb;\n    return this;\n  }\n\n  /**\n   * Registers a callback fired when `.resume()` was called.\n   */\n  onResume(cb: TweenCallback<T>) {\n    this._onResume = cb;\n    return this;\n  }\n\n  /**\n   * Registers a callback that is invoked **every time** one full cycle\n   * (repeat iteration) * of the tween has completed — but **before**\n   * the next repeat begins (if any remain).\n   *\n   * This is different from `onComplete`, which only fires once at the\n   * very end of the entire tween (after all repeats are finished).\n   */\n  onRepeat(cb?: TweenCallback<T>) {\n    this._onRepeat = cb;\n    return this;\n  }\n\n  /**\n   * Manually advances the tween to the given time.\n   * @param time - Current absolute time (performance.now style)\n   *\n   * @returns `true` if the tween is still playing after the update, `false`\n   * otherwise.\n   */\n  update(time = now()) {\n    // istanbul ignore else\n    if (!this._isPlaying) return false;\n\n    // istanbul ignore else\n    if (time < this._startTime) return true;\n\n    // istanbul ignore else\n    if (!this._startFired) {\n      this._onStart?.(this.state);\n      this._startFired = true;\n    }\n\n    const reversed = this._reversed;\n    const state = this.state;\n    const runtime = this._runtime;\n    let progress = (time - this._startTime) / this._duration;\n    // some limits are in good order for reverse\n    // if (progress < 0) progress = 0;\n    if (progress > 1) progress = 1;\n\n    // super cheap yoyo\n    let eased = this._easing(reversed ? 1 - progress : progress);\n    eased = reversed ? 1 - eased : eased;\n\n    const len = runtime.length;\n    let i = 0;\n    while (i < len) {\n      const prop = runtime[i++];\n      const targetObject = prop[0];\n      const property = prop[1];\n      const interpolator = prop[2];\n      const startVal = reversed ? prop[4] : prop[3];\n      const endVal = reversed ? prop[3] : prop[4];\n\n      if (typeof endVal === \"number\") {\n        state[property as keyof T] =\n          ((startVal as number) + (endVal - (startVal as number)) * eased) as T[\n            keyof T\n          ];\n      } else {\n        interpolator(\n          targetObject as never,\n          startVal as never,\n          endVal as never,\n          eased,\n        );\n      }\n    }\n\n    this._onUpdate?.(state, progress);\n\n    // istanbul ignore else\n    if (progress === 1) {\n      if (this._repeat === 0) {\n        this._isPlaying = false;\n        this._repeat = this._initialRepeat;\n        this._reversed = false;\n        this._onComplete?.(state);\n        return false;\n      }\n      // istanbul ignore else @preserve\n      if (this._repeat !== Infinity) this._repeat--;\n      // istanbul ignore else @preserve\n      if (this._yoyo) this._reversed = !reversed;\n      this._startTime = time;\n      this._startTime += this._repeatDelay;\n      this._onRepeat?.(state);\n      return true;\n    }\n\n    return true;\n  }\n\n  /**\n   * Public method to register an extension for a given property.\n   *\n   * **NOTES**\n   * - the extension will validate the initial values once `.use()` is called.\n   * - the `.use()` method must be called before `.to()` / `.from()`.\n   *\n   * @param property The property name\n   * @param extension The extension object\n   * @returns this\n   *\n   * @example\n   *\n   * const tween = new Tween({ myProp: { x: 0, y: 0 } });\n   * tween.use(\"myProp\", objectConfig);\n   */\n  use(property: string, { interpolate, validate }: PropConfig): this {\n    // istanbul ignore else\n    if (interpolate && !this._interpolators.has(property)) {\n      this._interpolators.set(property, interpolate);\n    }\n    if (validate && !this._validators.has(property)) {\n      this._validators.set(property, validate);\n    }\n    this._evaluate();\n    return this;\n  }\n\n  /**\n   * Internal method to reset state to initial values.\n   * @internal\n   */\n  private _resetState() {\n    deepAssign(this.state, this._state);\n  }\n\n  /**\n   * Reset starting values, end values and runtime.\n   */\n  clear() {\n    this._propsStart = {} as T;\n    this._propsEnd = {} as T;\n    this._runtime.length = 0;\n    this._startTime = 0;\n    this._pauseStart = 0;\n    this._repeat = 0;\n    this._initialRepeat = 0;\n    return this;\n  }\n\n  /**\n   * Internal method to handle instrumentation of start and end values for interpolation.\n   * @internal\n   */\n  private _setProps(\n    obj: T,\n    propsStart: Partial<T>,\n    propsEnd: Partial<T>,\n    overrideStartingValues: boolean,\n  ): void {\n    const endKeys = Object.keys(propsEnd) as (keyof T)[];\n    const len = endKeys.length;\n    this._runtime.length = 0;\n    let rtLen = 0;\n    let i = 0;\n\n    while (i < len) {\n      const property = endKeys[i++];\n\n      // Save the starting value, but only once unless override is requested.\n      // istanbul ignore else\n      if (\n        typeof propsStart[property] === \"undefined\" ||\n        overrideStartingValues\n      ) {\n        const objValue = obj[property] as T[keyof T];\n\n        // Update start property value\n        if (isObject(objValue) || isArray(objValue)) {\n          propsStart[property] = deproxy(objValue);\n        } else {\n          // number\n          propsStart[property] = objValue;\n        }\n\n        // Pre-register interpolator\n        const interpolator = this._interpolators.get(property) || null;\n\n        // Store all values needed for interpolation\n        this._runtime[rtLen++] = [\n          objValue,\n          property,\n          interpolator,\n          propsStart[property] as T[keyof T],\n          propsEnd[property] as T[keyof T],\n        ] as TweenRuntime<T>;\n      }\n    }\n  }\n\n  /**\n   * Internal method to handle validation of initial values, start and end values.\n   * @internal\n   */\n  private _evaluate(newObj?: Partial<T> | DeepPartial<T>) {\n    // the reference of the initialization state is stored here\n    // istanbul ignore else @preserve\n    if (!this.isValidState) {\n      const temp = this._state;\n      validateValues.call(this as unknown as Tween, temp);\n      // istanbul ignore else @preserve\n      if (this.isValid) {\n        this.state = temp;\n        this._state = deproxy(temp);\n      }\n    } else if (newObj) {\n      validateValues.call(this as unknown as Tween, newObj, this._state);\n    }\n    return this;\n  }\n\n  /**\n   * Internal method to provide feedback on validation issues.\n   * @internal\n   */\n  private _report() {\n    // istanbul ignore else @preserve\n    if (!this.isValid) {\n      const message = [\n        \"[Tween] failed validation:\",\n        \"- \" + Array.from(this._errors.values()).join(\"\\n- \"),\n      ];\n\n      console.warn(message.join(\"\\n\"));\n    }\n    return this;\n  }\n}\n","// Timeline.ts\nimport type {\n  DeepPartial,\n  InterpolatorFunction,\n  Position,\n  PropConfig,\n  TimelineCallback,\n  TimelineEntry,\n  TimelineEntryConfig,\n  TweenProps,\n  ValidationFunction,\n} from \"./types.d.ts\";\nimport { addToQueue, removeFromQueue } from \"./Runtime.ts\";\nimport {\n  deepAssign,\n  deproxy,\n  isArray,\n  isObject,\n  validateValues,\n} from \"./Util.ts\";\nimport { now } from \"./Now.ts\";\n\n/**\n * Timeline orchestrates multiple tweens with scheduling, overlaps, labels and repeat.\n * Supports numbers and via extensions it enxtends to arrays\n * (e.g. RGB, points), nested objects, and SVG path morphing.\n *\n * @template T - Type of the animated state object\n *\n * @example\n * ```ts\n * const tl = new Timeline({ x: 0, opacity: 0 })\n *   .to({ x: 300, duration: 1.2 })\n *   .to({ opacity: 1, duration: 0.8 }, \"-=0.4\")\n *   .play();\n * ```\n *\n * @param initialValues The initial values object\n */\nexport class Timeline<T extends TweenProps = TweenProps> {\n  public state: T;\n  private _state: T;\n  private _entries: TimelineEntry<T>[] = [];\n  private _labels = new Map<string, number>();\n  private _progress = 0;\n  private _duration = 0;\n  private _yoyo = false;\n  private _reversed = false;\n  private _time = 0;\n  private _pauseTime = 0;\n  private _lastTime = 0;\n  private _isPlaying = false;\n  private _repeat = 0;\n  private _repeatDelay = 0;\n  private _repeatDelayStart = 0;\n  private _initialRepeat = 0;\n  private _errors = new Map<string | \"init\", string>();\n  private _interpolators = new Map<string | keyof T, InterpolatorFunction>();\n  private _validators = new Map<string | keyof T, ValidationFunction>();\n  private _onStart?: TimelineCallback<T>;\n  private _onStop?: TimelineCallback<T>;\n  private _onPause?: TimelineCallback<T>;\n  private _onResume?: TimelineCallback<T>;\n  private _onUpdate?: TimelineCallback<T>;\n  private _onComplete?: TimelineCallback<T>;\n  private _onRepeat?: TimelineCallback<T>;\n\n  /**\n   * Creates a new Timeline instance.\n   * @param initialValues - The initial state of the animated object\n   */\n  constructor(initialValues: T) {\n    // we must initialize state to allow isValidState to work from here\n    this.state = {} as T;\n    validateValues.call(this as Timeline, initialValues);\n    if (this._errors.size) {\n      // we temporarily store initialValues reference here\n      this._state = initialValues;\n    } else {\n      this.state = initialValues;\n      this._state = { ...initialValues };\n    }\n\n    return this;\n  }\n\n  // GETTERS FIRST\n  /**\n   * Returns the current [0-1] progress value.\n   */\n  get progress() {\n    return this._progress;\n  }\n\n  /**\n   * Returns the total duration in seconds.\n   */\n  get duration() {\n    return this._duration / 1000;\n  }\n\n  /**\n   * Returns the total duration in seconds, which is a sum of all entries duration\n   * multiplied by repeat value and repeat delay multiplied by repeat value.\n   */\n  get totalDuration() {\n    const repeat = this._initialRepeat;\n    return (\n      this._duration * (repeat + 1) +\n      this._repeatDelay * repeat\n    ) / 1000;\n  }\n\n  /**\n   * A boolean that returns `true` when timeline is playing.\n   */\n  get isPlaying(): boolean {\n    return this._isPlaying;\n  }\n\n  /**\n   * A boolean that returns `true` when timeline is paused.\n   */\n  get isPaused(): boolean {\n    return !this._isPlaying && this._pauseTime > 0;\n  }\n\n  /**\n   * A boolean that returns `true` when initial values are valid.\n   */\n  get isValidState(): boolean {\n    return Object.keys(this.state).length > 0;\n  }\n\n  /**\n   * A boolean that returns `true` when all values are valid.\n   */\n  get isValid(): boolean {\n    return this._errors.size === 0;\n  }\n\n  /**\n   * Returns the validator configured for a given property.\n   */\n  getValidator(propName: string) {\n    return this._validators.get(propName);\n  }\n\n  /**\n   * Returns the errors Map, mainly used by external validators.\n   */\n  getErrors() {\n    return this._errors;\n  }\n\n  /**\n   * Starts or resumes playback from the beginning (or current time if resumed).\n   * Triggers the `onStart` callback if set.\n   * @param startTime - Optional explicit start timestamp (defaults to now)\n   * @returns this\n   */\n  play(time = now()): this {\n    if (this._pauseTime) return this.resume();\n    if (this._isPlaying) return this;\n    if (!this.isValid) {\n      this._report();\n      return this;\n    }\n    if (this._time) this._resetState();\n    this._isPlaying = true;\n    this._lastTime = time;\n    this._time = 0;\n    this._onStart?.(this.state, 0);\n\n    addToQueue(this);\n    return this;\n  }\n\n  /**\n   * Pauses playback (preserves current time).\n   * Triggers the `onPause` callback if set.\n   * @returns this\n   */\n  pause(time = now()): this {\n    if (!this._isPlaying) return this;\n    this._isPlaying = false;\n    this._pauseTime = time;\n    this._onPause?.(this.state, this.progress);\n    return this;\n  }\n\n  /**\n   * Resumes from paused state (adjusts internal clock).\n   * Triggers the `onResume` callback if set.\n\n   * @param time - Optional current timestamp (defaults to now)\n   * @returns this\n   */\n  resume(time = now()): this {\n    if (this._isPlaying) return this;\n    this._isPlaying = true;\n    const dif = time - this._pauseTime;\n    this._pauseTime = 0;\n    this._lastTime += dif;\n    this._onResume?.(this.state, this.progress);\n\n    addToQueue(this);\n    return this;\n  }\n\n  /**\n   * Reverses playback direction and mirrors current time position.\n   * @returns this\n   */\n  reverse(): this {\n    if (!this._isPlaying) return this;\n\n    this._reversed = !this._reversed;\n    this._time = this._duration - this._time;\n\n    // istanbul ignore else @preserve\n    if (this._initialRepeat > 0) {\n      this._repeat = this._initialRepeat - this._repeat;\n    }\n\n    return this;\n  }\n\n  /**\n   * Jumps to a specific time or label. When playback is reversed\n   * the time is adjusted.\n   * @param pointer - Seconds or label name\n   * @returns this\n   */\n  seek(pointer: number | string): this {\n    const elapsed = this._resolvePosition(pointer);\n\n    this._time = elapsed;\n    return this;\n  }\n\n  /**\n   * Stops playback, resets time to 0, and restores initial state.\n   * Triggers the `onStop` callback if set.\n   * @returns this\n   */\n  stop(): this {\n    if (!this._isPlaying) return this;\n    this._isPlaying = false;\n    this._time = 0;\n    this._pauseTime = 0;\n    this._repeat = this._initialRepeat;\n    this._reversed = false;\n    removeFromQueue(this);\n    this._onStop?.(this.state, this._progress);\n    return this;\n  }\n\n  /**\n   * Sets the number of times the timeline should repeat.\n   * @param count - Number of repeats (0 = once, Infinity = loop forever)\n   * @returns this\n   */\n  repeat(count = 0): this {\n    this._repeat = count;\n    this._initialRepeat = count;\n    return this;\n  }\n\n  /**\n   * Sets a number of seconds to delay the animation\n   * after each repeat.\n   * @param amount - How many seconds to delay\n   * @default 0 seconds\n   * @returns this\n   */\n  repeatDelay(amount = 0) {\n    this._repeatDelay = amount * 1000;\n    return this;\n  }\n\n  /**\n   * Sets to Timeline entries to tween from end to start values.\n   * The easing is also goes backwards.\n   * This requires repeat value of at least 1.\n   * @param yoyo - When `true` values are reversed\n   * @default false\n   * @returns this\n   */\n  yoyo(yoyo = false) {\n    this._yoyo = yoyo;\n    return this;\n  }\n\n  /**\n   * Adds a named time position for use in `.seek(\"label\")`.\n   * @param name - Label identifier\n   * @param position - Time offset or relative position\n   * @returns this\n   */\n  label(name: string, position?: Position): this {\n    this._labels.set(name, this._resolvePosition(position));\n    return this;\n  }\n\n  /**\n   * Adds a new tween entry to the timeline.\n   * @param config - Values to animate + duration, easing, etc.\n   * @param position - Start offset: number, \"+=0.5\", \"-=0.3\", or label name\n   * @returns this (chainable)\n   */\n  to(\n    {\n      duration = 1,\n      easing = (t) => t,\n      ...values\n    }: (Partial<T> | DeepPartial<T>) & TimelineEntryConfig,\n    position: Position = \"+=0\",\n  ): this {\n    if (!this.isValidState || this._isPlaying) return this;\n\n    this._evaluate(values as Partial<T> | DeepPartial<T>);\n    if (this.isValid) {\n      const startTime = this._resolvePosition(position);\n      const to = values as Partial<T> | DeepPartial<T>;\n      const from = {} as Partial<T>;\n      const entryDuration = duration * 1000;\n      const runtime = [] as TimelineEntry<T>[\"runtime\"];\n\n      this._entries.push({\n        from,\n        to,\n        runtime,\n        startTime,\n        duration: entryDuration,\n        easing,\n        isActive: false,\n      });\n\n      const endTime = startTime + entryDuration;\n      this._duration = Math.max(this._duration, endTime);\n    }\n    return this;\n  }\n\n  /**\n   * Registers a callback fired when playback begins.\n   */\n  onStart(cb: TimelineCallback<T>): this {\n    this._onStart = cb;\n    return this;\n  }\n\n  /**\n   * Registers a callback fired when `pause()` was called.\n   */\n  onPause(cb: TimelineCallback<T>): this {\n    this._onPause = cb;\n    return this;\n  }\n\n  /**\n   * Registers a callback fired when `.play()` / `.resume()` was called.\n   */\n  onResume(cb: TimelineCallback<T>): this {\n    this._onResume = cb;\n    return this;\n  }\n\n  /**\n   * Registers a callback fired on explicit `.stop()`.\n   */\n  onStop(cb: TimelineCallback<T>): this {\n    this._onStop = cb;\n    return this;\n  }\n\n  /**\n   * Registers a callback fired every frame.\n   */\n  onUpdate(cb: TimelineCallback<T>): this {\n    this._onUpdate = cb;\n    return this;\n  }\n\n  /**\n   * Registers a callback fired when timeline naturally completes.\n   */\n  onComplete(cb: TimelineCallback<T>): this {\n    this._onComplete = cb;\n    return this;\n  }\n\n  /**\n   * Registers a callback fired when `.play()` / `.resume()` was called.\n   */\n  onRepeat(cb?: TimelineCallback<T>) {\n    this._onRepeat = cb;\n    return this;\n  }\n\n  /**\n   * Public method to register an extension for a given property.\n   *\n   * **NOTES**\n   * - the extension will validate the initial values once `.use()` is called.\n   * - the `.use()` method must be called before `.to()`.\n   *\n   * @param property The property name\n   * @param extension The extension object\n   * @returns this\n   *\n   * @example\n   *\n   * const timeline = new Timeline({ myProp: { x: 0, y: 0 } });\n   * timeline.use(\"myProp\", objectConfig);\n   */\n  use(property: string, { interpolate, validate }: PropConfig): this {\n    // istanbul ignore else\n    if (interpolate && !this._interpolators.has(property)) {\n      this._interpolators.set(property, interpolate);\n    }\n    if (validate && !this._validators.has(property)) {\n      this._validators.set(property, validate);\n    }\n    this._evaluate();\n    return this;\n  }\n\n  /**\n   * Manually advances the timeline to the given time.\n   * @param time - Current absolute time (performance.now style)\n   *\n   * @returns `true` if the timeline is still playing after the update, `false`\n   * otherwise.\n   */\n  update(time = now()) {\n    if (!this._isPlaying) return false;\n\n    if (this._repeatDelayStart) {\n      if (time - this._repeatDelayStart < this._repeatDelay) {\n        this._lastTime = time; // Update lastTime to prevent delta accumulation\n        return true;\n      }\n      // Delay complete\n      this._repeatDelayStart = 0;\n    }\n\n    const delta = time - this._lastTime;\n    const reversed = this._reversed;\n    this._lastTime = time;\n    this._time += delta;\n\n    this._progress = this._time > this._duration\n      ? 1\n      : this._time / this._duration;\n\n    const entries = this._entries;\n    const state = this.state;\n    const entriesLen = entries.length;\n    let i = 0;\n\n    while (i < entriesLen) {\n      const entry = entries[i++];\n\n      // reverse start time\n      const startTime = !reversed\n        ? entry.startTime\n        : this._duration - entry.startTime - entry.duration;\n\n      const localTime = this._time - startTime;\n\n      // Calculate local time within the entry's duration\n      let tweenElapsed = localTime / entry.duration;\n      // some limits are in good order for reverse\n      if (tweenElapsed > 1) tweenElapsed = 1;\n      if (tweenElapsed < 0) tweenElapsed = 0;\n\n      // Only build runtime once on first activation\n      if (!entry.isActive && tweenElapsed > 0 && tweenElapsed < 1) {\n        // istanbul ignore else @preserve\n        if (entry.runtime.length === 0) {\n          this._setEntry(entry, state);\n        }\n        entry.isActive = true;\n      }\n\n      // istanbul ignore else @preserve\n      if (entry.isActive) {\n        // super cheap yoyo\n        let easedValue = entry.easing(\n          reversed ? 1 - tweenElapsed : tweenElapsed,\n        );\n        easedValue = reversed ? 1 - easedValue : easedValue;\n        const runtime = entry.runtime;\n\n        const runtimeLen = runtime.length;\n        let j = 0;\n        while (j < runtimeLen) {\n          const prop = runtime[j++];\n          const targetObject = prop[0];\n          const property = prop[1];\n          const interpolator = prop[2];\n          const startVal = reversed ? prop[4] : prop[3];\n          const endVal = reversed ? prop[3] : prop[4];\n\n          if (typeof endVal === \"number\") {\n            state[property as keyof T] = ((startVal as number) +\n              (endVal - (startVal as number)) * easedValue) as T[keyof T];\n          } else {\n            interpolator(\n              targetObject as never,\n              startVal as never,\n              endVal as never,\n              easedValue,\n            );\n          }\n        }\n        if (tweenElapsed === 1) entry.isActive = false;\n      }\n    }\n\n    this._onUpdate?.(state, this._progress);\n\n    // istanbul ignore else\n    if (this._progress === 1) {\n      // istanbul ignore else\n      if (this._repeat === 0) {\n        this._isPlaying = false;\n        this._repeat = this._initialRepeat;\n        this._reversed = false;\n        this._onComplete?.(state, 1);\n        this._resetState(true);\n\n        return false;\n      }\n\n      // istanbul ignore else @preserve\n      if (this._repeat !== Infinity) this._repeat--;\n      if (this._yoyo) this._reversed = !reversed;\n\n      this._time = 0;\n      this._resetState();\n      this._onRepeat?.(state, this.progress);\n\n      if (this._repeatDelay > 0) this._repeatDelayStart = time;\n\n      return true;\n    }\n\n    return true;\n  }\n\n  /**\n   * Public method to clear all entries, labels and reset timers to zero\n   * or initial value (repeat).\n   */\n  clear() {\n    this._entries.length = 0;\n    this._duration = 0;\n    this._labels.clear();\n    this._time = 0;\n    this._progress = 0;\n    this._pauseTime = 0;\n    this._lastTime = 0;\n    this._repeatDelay = 0;\n    this._repeat = this._initialRepeat;\n    this._repeatDelayStart = 0;\n    this._reversed = false;\n    return this;\n  }\n\n  /**\n   * Internal method to handle instrumentation of start and end values for interpolation\n   * of a tween entry. Only called once per entry on first activation.\n   * @internal\n   */\n  private _setEntry(entry: TimelineEntry<T>, state: T) {\n    const from = entry.from as Partial<T>;\n    const to = entry.to as Partial<T>;\n    const keysTo = Object.keys(to) as (keyof T)[];\n    const keyLen = keysTo.length;\n    entry.runtime = new Array(keyLen);\n    let rtLen = 0;\n    let j = 0;\n\n    while (j < keyLen) {\n      const key = keysTo[j++];\n      const objValue = state[key] as T[keyof T];\n\n      // Capture current state value for 'from'\n      if (isObject(objValue) || isArray(objValue)) {\n        from[key] = deproxy(objValue);\n      } else {\n        // number\n        from[key] = objValue;\n      }\n\n      const interpolator = this._interpolators.get(key) || null;\n\n      // Push tuple\n      entry.runtime[rtLen++] = [\n        objValue,\n        key,\n        interpolator,\n        from[key] as T[keyof T],\n        to[key] as T[keyof T],\n      ] as TimelineEntry<T>[\"runtime\"][0];\n    }\n  }\n\n  /**\n   * Internal method to revert state to initial values and reset entry flags.\n   * @internal\n   */\n  private _resetState(isComplete = false) {\n    let i = 0;\n    const entriesLen = this._entries.length;\n    while (i < entriesLen) {\n      const entry = this._entries[i++];\n      entry.isActive = false;\n    }\n    if (!isComplete) {\n      deepAssign(this.state, this._state);\n    }\n  }\n\n  /**\n   * Internal method to resolve the position relative to the current duration\n   * or a set value in seconds.\n   * @internal\n   */\n  private _resolvePosition(pos?: Position): number {\n    if (typeof pos === \"number\") {\n      return Math.min(this._duration, Math.max(0, pos * 1000));\n    }\n\n    // istanbul ignore else @preserve\n    if (typeof pos === \"string\") {\n      // First try label\n      const labelTime = this._labels.get(pos);\n      if (labelTime !== undefined) return labelTime;\n\n      // Then relative\n      // istanbul ignore else @preserve\n      if (pos.startsWith(\"+=\") || pos.startsWith(\"-=\")) {\n        let offset = parseFloat(pos.slice(2));\n        if (isNaN(offset)) offset = 0;\n        offset *= 1000;\n        return pos.startsWith(\"+=\")\n          ? this._duration + offset\n          : Math.max(0, this._duration - offset);\n      }\n    }\n\n    // Fallback to current duration\n    return this._duration;\n  }\n\n  /**\n   * Internal method to handle validation of initial values and entries values.\n   * @internal\n   */\n  private _evaluate(newObj?: Partial<T> | DeepPartial<T>) {\n    // the reference of the initialization state is stored here\n    // istanbul ignore else @preserve\n    if (!this.isValidState) {\n      const temp = this._state;\n      validateValues.call(this as Timeline, temp);\n      // istanbul ignore else @preserve\n      if (this.isValid) {\n        this.state = temp;\n        this._state = deproxy(temp);\n      }\n    } else if (newObj) {\n      validateValues.call(this as Timeline, newObj, this._state);\n    }\n    return this;\n  }\n\n  /**\n   * Internal method to provide feedback on validation issues.\n   * @internal\n   */\n  private _report() {\n    // istanbul ignore else @preserve\n    if (!this.isValid) {\n      const message = [\n        \"[Timeline] failed validation:\",\n        \"- \" + Array.from(this._errors.values()).join(\"\\n- \"),\n      ].join(\"\\n\");\n\n      console.warn(message);\n    }\n    return this;\n  }\n}\n",""],"mappings":"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"}